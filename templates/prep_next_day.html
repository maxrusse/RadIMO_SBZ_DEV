<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RadIMO Cortex | Change Today / Prep Tomorrow</title>
  <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #f0f0f0; padding: 1rem; max-width: 1800px; margin: 0 auto; }
    .header { background: #004892; color: white; padding: 1rem 2rem; border-radius: 8px; margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    .header h1 { margin: 0; font-size: 1.5rem; }
    .header-actions { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .header-actions a, .header-actions button { color: white; text-decoration: none; padding: 0.5rem 1rem; background: rgba(255,255,255,0.2); border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; }
    .header-actions a:hover, .header-actions button:hover { background: rgba(255,255,255,0.3); }
    .card { background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 1rem; }

    /* Tab Styles - colors generated dynamically from config */
    .tab-container { display: flex; gap: 0; margin-bottom: 0; }
    .tab-btn { padding: 1rem 2rem; border: none; background: #e0e0e0; color: #666; font-size: 1rem; font-weight: 600; cursor: pointer; border-radius: 8px 8px 0 0; transition: all 0.2s; }
    .tab-btn:hover { background: #d0d0d0; }
    /* .tab-btn.active-today and .tab-btn.active-tomorrow generated from UI_COLORS */
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    /* Today/Tomorrow Banners - colors generated dynamically from config */
    .today-banner, .tomorrow-banner { padding: 1rem; border-radius: 0 8px 8px 8px; margin-bottom: 1rem; }
    .today-banner h2, .tomorrow-banner h2 { margin-bottom: 0.5rem; font-size: 1.2rem; }
    .today-banner p, .tomorrow-banner p { margin: 0.25rem 0; font-size: 0.9rem; }

    /* Table Styles */
    .table-container { overflow: visible; }
    .edit-table { width: 100%; border-collapse: collapse; font-size: 0.78rem; }
    .edit-table th, .edit-table td { padding: 0.15rem 0.2rem; text-align: left; border: 1px solid #e5e5e5; vertical-align: top; }
    .edit-table th { background: #f8f9fa; font-weight: 600; position: sticky; top: 0; z-index: 10; white-space: nowrap; }
    .edit-table tr:hover { background: #f8f9fa; }
    .compact-grid th { text-align: center; }
    .compact-grid .header-top th { font-size: 0.75rem; padding: 0.25rem 0.15rem; }
    .compact-grid .header-sub th { font-size: 0.7rem; padding: 0.15rem 0.15rem; background: #eef1f5; }
    .compact-grid .sub-col { min-width: 32px; }
    .compact-grid .skill-header { color: white; }
    .compact-grid .grid-row td { text-align: center; vertical-align: middle; }
    .compact-grid .worker-col { min-width: 150px; text-align: left !important; }
    .compact-grid .shift-col { min-width: 130px; text-align: left !important; }
    .compact-grid .task-col { min-width: 100px; text-align: left !important; }
    .grid-select { width: 100%; padding: 0.15rem; font-size: 0.72rem; }
    .grid-input { width: 24px; padding: 0.1rem; font-size: 0.72rem; text-align: center; border: 1px solid #ccc; border-radius: 3px; font-weight: 600; }
    .grid-input:focus { outline: 2px solid #004892; border-color: #004892; }
    .grid-mod-input { width: 32px; padding: 0.1rem; font-size: 0.68rem; text-align: center; border: 1px solid #ccc; border-radius: 3px; }
    .grid-mod-input:focus { outline: 2px solid #17a2b8; border-color: #17a2b8; }
    .grid-badge { display: inline-block; min-width: 20px; padding: 0.05rem 0.15rem; font-size: 0.72rem; font-weight: 600; text-align: center; }
    .grid-cell { background: #fff; }
    .grid-cell.ghost { background: #fafafa; color: #999; }
    .grid-modifier { min-width: 42px; }
    .modifier-col { min-width: 50px; }
    .row-skill-flag { background: #e9f7ef; }

    /* Badges - colors are dynamically generated from MODALITY_SETTINGS */
    .badge { display: inline-block; padding: 0.15rem 0.3rem; margin: 0.05rem; border-radius: 3px; font-size: 0.7rem; font-weight: 600; }
    .badge-default { background: #6c757d; color: white; }

    /* Skill cells - borderless, colors generated dynamically from SKILL_VALUE_COLORS */
    .skill-cell { text-align: center; font-size: 0.7rem; }
    .skill-val { padding: 0.05rem 0.15rem; font-size: 0.72rem; font-weight: 600; text-align: center; }
    /* .skill-val-1, .skill-val-0, .skill-val--1, .skill-val-w colors generated from config */

    /* Multi-modality chips per skill */
    .mod-skill-grid { display: flex; flex-wrap: wrap; gap: 0.15rem; }
    .mod-skill-chip { display: inline-flex; align-items: center; gap: 0.15rem; padding: 0.1rem 0.15rem; border-radius: 4px; background: #f8f9fa; border: 1px solid #dee2e6; }
    .mod-skill-chip .badge { margin: 0; }
    .mod-skill-chip select { padding: 0.1rem; font-size: 0.7rem; width: 38px; }
    .mod-skill-chip.ghost { opacity: 0.7; border-style: dashed; }
    .skill-bundle { min-width: 100px; }

    /* Aggregated skill/modality cells */
    .agg-cell { text-align: center; font-size: 0.7rem; min-width: 42px; }
    .agg-val { padding: 0.15rem 0.3rem; font-size: 0.72rem; display: inline-block; min-width: 26px; background: #f7f7f7; color: #333; }
    .agg-all-1 { background: #f7f7f7; }
    .agg-any-1 { background: #f7f7f7; }
    .agg-all-0 { background: #f7f7f7; }
    .agg-any-0 { background: #f7f7f7; }
    .agg-all-neg { background: #f7f7f7; }
    .agg-mixed { background: #f7f7f7; }
    /* .agg-has-weighted generated from SKILL_VALUE_COLORS.weighted */

    /* Workload modifier badge - .modifier-high generated from config */
    .modifier-badge { display: inline-block; padding: 0.1rem 0.3rem; border-radius: 3px; font-size: 0.65rem; font-weight: 600; margin-left: 0.3rem; }
    .modifier-low { background: #6f42c1; color: white; }     /* Modifier < 1: lower weight (freshman) */

    /* View toggle */
    .view-toggle { display: flex; gap: 0; border: 2px solid #004892; border-radius: 6px; overflow: hidden; }
    .view-toggle-btn { padding: 0.4rem 1rem; border: none; background: white; color: #004892; font-size: 0.85rem; font-weight: 600; cursor: pointer; transition: all 0.2s; }
    .view-toggle-btn:hover { background: #e9ecef; }
    .view-toggle-btn.active { background: #004892; color: white; }
    .view-toggle-container { display: flex; align-items: center; gap: 0.75rem; }

    /* Filters */
    .filter-bar { display: flex; gap: 0.75rem; flex-wrap: wrap; align-items: flex-end; margin-bottom: 0.75rem; }
    .filter-group { display: flex; flex-direction: column; gap: 0.2rem; }
    .filter-group label { font-size: 0.75rem; color: #555; }
    .filter-group select { padding: 0.3rem; border: 1px solid #ccc; border-radius: 4px; font-size: 0.82rem; min-width: 140px; }
    .filter-toggle { display: flex; align-items: center; gap: 0.35rem; font-size: 0.82rem; color: #333; }

    /* Summary */
    .summary-wrapper { margin-top: 0.75rem; background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 6px; padding: 0.75rem; }
    .summary-title { font-weight: 600; font-size: 0.85rem; margin-bottom: 0.4rem; color: #004892; }
    .summary-table { width: 100%; border-collapse: collapse; font-size: 0.78rem; }
    .summary-table th, .summary-table td { border: 1px solid #ddd; padding: 0.25rem 0.4rem; text-align: center; }
    .summary-table th { background: #eef1f5; }

    /* Duplicate worker indicator */
    .worker-name { font-weight: 500; }
    .worker-name.duplicate { position: relative; }
    .worker-name.duplicate::after { content: '★'; color: #ffc107; margin-left: 0.3rem; font-size: 0.8rem; }
    .duplicate-badge { background: #ffc107; color: #333; padding: 0.1rem 0.3rem; border-radius: 3px; font-size: 0.65rem; margin-left: 0.3rem; font-weight: 600; }

    /* Shift time display */
    .shift-time { font-family: monospace; font-size: 0.85rem; }

    /* Task badges */
    .task-badge { display: inline-block; padding: 0.15rem 0.4rem; margin: 0.1rem; border-radius: 3px; font-size: 0.7rem; background: #e9ecef; color: #495057; }
    .task-badge.exclusion { background: #f8d7da; color: #721c24; }

    /* Buttons */
    .btn { padding: 0.4rem 0.8rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem; font-weight: 600; }
    .btn-primary { background: #004892; color: white; }
    .btn-primary:hover { background: #003670; }
    .btn-secondary { background: #6c757d; color: white; }
    .btn-secondary:hover { background: #5a6268; }
    .btn-success { background: #28a745; color: white; }
    .btn-success:hover { background: #218838; }
    .btn-warning { background: #ffc107; color: #333; }
    .btn-warning:hover { background: #e0a800; }
    .btn-danger { background: #dc3545; color: white; }
    .btn-danger:hover { background: #c82333; }
    .btn-small { padding: 0.2rem 0.4rem; font-size: 0.7rem; }

    /* Message */
    .message { padding: 1rem; border-radius: 4px; margin-bottom: 1rem; display: none; }
    .message.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; display: block; }
    .message.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; display: block; }

    /* Add Panel */
    .add-panel { background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; border: 2px solid #28a745; }
    .add-panel.tomorrow { border-color: #ffc107; }
    .add-panel h4 { margin: 0 0 0.75rem 0; color: #28a745; font-size: 1rem; }
    .add-panel.tomorrow h4 { color: #856404; }
    .add-row { display: flex; gap: 0.75rem; flex-wrap: wrap; align-items: flex-end; }
    .add-row .form-group { display: flex; flex-direction: column; }
    .add-row .form-group label { font-size: 0.75rem; font-weight: 600; margin-bottom: 0.2rem; color: #666; }
    .add-row select, .add-row input { padding: 0.4rem; border: 1px solid #ccc; border-radius: 4px; font-size: 0.85rem; }

    /* Modal */
    .modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center; }
    .modal-overlay.show { display: flex; }
    .modal { background: white; padding: 1.5rem; border-radius: 8px; max-width: 700px; width: 95%; max-height: 85vh; overflow-y: auto; }
    .modal h3 { margin: 0 0 1rem 0; }
    .modal-actions { margin-top: 1rem; display: flex; gap: 0.5rem; justify-content: flex-end; }

    /* Worker group separator in table */
    .worker-group-first td { border-top: 2px solid #004892; }

    /* Dropdown select */
    .worker-select { padding: 0.3rem; border: 1px solid #ccc; border-radius: 3px; font-size: 0.8rem; max-width: 150px; }

    /* Action buttons cell */
    .action-cell { white-space: nowrap; }
    .action-cell .btn { margin: 0.1rem; }
  </style>
</head>
<body>
  <div class="header">
    <div>
      <h1>RadIMO Cortex | Change Today / Prep Tomorrow</h1>
      <p style="font-size: 0.85rem; opacity: 0.9;">Manage current schedule or prepare tomorrow's schedule</p>
    </div>
    <div class="header-actions">
      <a href="{{ url_for('index') }}">Dashboard</a>
      <a href="{{ url_for('timetable') }}">Timetable</a>
      <a href="{{ url_for('skill_roster_page') }}">Skill Matrix</a>
      <a href="{{ url_for('upload_file') }}">Upload</a>
      <a href="{{ url_for('logout') }}">Logout</a>
    </div>
  </div>

  <div id="message-container"></div>

  <!-- Tab Navigation -->
  <div class="tab-container">
    <button class="tab-btn active-today" onclick="switchTab('today')" id="tab-today">Change Today</button>
    <button class="tab-btn" onclick="switchTab('tomorrow')" id="tab-tomorrow">Prep Tomorrow</button>
  </div>

  <!-- TODAY TAB -->
  <div id="content-today" class="tab-content active">
    <div class="today-banner">
      <h2>LIVE CHANGES - Immediate Effect</h2>
      <p>Changes here apply IMMEDIATELY to today's schedule. <strong>Counters are NOT reset.</strong></p>
    </div>

    <div class="card" style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: center;">
      <strong>Load Today from CSV:</strong>
      <button class="btn btn-success" onclick="loadFromCSV('today')">Load Today</button>
      <span id="load-status-today" style="color: #666;"></span>
      <button class="btn btn-primary" onclick="openAddWorkerModal('today')" style="margin-left: auto;">+ Add Worker</button>
    </div>

      <div class="card">

      <!-- Controls -->
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 0.5rem;">
        <div style="display: flex; gap: 0.5rem; align-items: center;">
          <button class="btn btn-secondary" onclick="toggleEditMode('today')" id="edit-mode-btn-today">Quick Edit</button>
          <button class="btn btn-success" onclick="saveInlineChanges('today')" id="save-inline-btn-today" style="display: none;">Save Changes</button>
        </div>
        <div style="font-size: 0.75rem; color: #666;">
          <span class="skill-val skill-val-1">1</span> Active
          <span class="skill-val skill-val-0">0</span> Passive
          <span class="skill-val skill-val--1">-1</span> Excluded
          <span class="skill-val skill-val-w">w</span> Weighted
        </div>
      </div>

      <div class="filter-bar">
        <div class="filter-group">
          <label>Filter Modality</label>
          <select id="filter-modality-today" onchange="updateTableFilter('today')">
            <option value="">All</option>
            {% for mod in modalities %}
            <option value="{{ mod|lower }}">{{ mod|upper }}</option>
            {% endfor %}
          </select>
        </div>
        <div class="filter-group">
          <label>Filter Skill</label>
          <select id="filter-skill-today" onchange="updateTableFilter('today')">
            <option value="">All</option>
            {% for skill in skills %}
            <option value="{{ skill }}">{{ skill }}</option>
            {% endfor %}
          </select>
        </div>
        <label class="filter-toggle">
          <input type="checkbox" id="filter-hide-zero-today" onchange="updateTableFilter('today')"> Hide 0/-1
        </label>
        <button id="display-order-toggle" class="btn btn-secondary" onclick="toggleDisplayOrder()" title="Current: Modalities as groups, skills as sub-columns. Click to switch." style="margin-left: auto;">Mod → Skill</button>
      </div>

      <!-- Worker Table - One row per entry -->
      <div class="table-container">
        <table class="edit-table compact-grid" id="edit-table-today">
          <thead id="table-head-today">
            <tr>
              <th>Worker</th>
              <th>Modality</th>
              <th>Shift</th>
              {% for skill in skills %}
              <th class="skill-cell">{{ skill }}</th>
              {% endfor %}
              <th>Task</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="table-body-today"></tbody>
        </table>
      </div>
      <div id="summary-today" class="summary-wrapper"></div>
      <p style="margin-top: 0.5rem; font-size: 0.75rem; color: #666;">★ = Worker has multiple entries (double shift)</p>
    </div>
  </div>

  <!-- TOMORROW TAB -->
  <div id="content-tomorrow" class="tab-content">
    <div class="tomorrow-banner">
      <h2>STAGING MODE - Prep for Tomorrow</h2>
      <p>Changes are saved to STAGED area for tomorrow. <strong>Counter reset happens on CSV import.</strong></p>
    </div>

    <div class="card" style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: center;">
      <strong>Load Next Day from CSV:</strong>
      <button class="btn btn-warning" onclick="loadFromCSV('next')">Load Next Day</button>
      <span id="load-status-tomorrow" style="color: #666;"></span>
      <button class="btn btn-primary" onclick="openAddWorkerModal('tomorrow')" style="margin-left: auto;">+ Add Worker</button>
    </div>

      <div class="card">
      <!-- Controls -->
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 0.5rem;">
        <div style="display: flex; gap: 0.5rem; align-items: center;">
          <button class="btn btn-secondary" onclick="toggleEditMode('tomorrow')" id="edit-mode-btn-tomorrow">Quick Edit</button>
          <button class="btn btn-success" onclick="saveInlineChanges('tomorrow')" id="save-inline-btn-tomorrow" style="display: none;">Save Changes</button>
        </div>
        <div style="font-size: 0.75rem; color: #666;">
          <span class="skill-val skill-val-1">1</span> Active
          <span class="skill-val skill-val-0">0</span> Passive
          <span class="skill-val skill-val--1">-1</span> Excluded
          <span class="skill-val skill-val-w">w</span> Weighted
        </div>
      </div>

      <div class="filter-bar">
        <div class="filter-group">
          <label>Filter Modality</label>
          <select id="filter-modality-tomorrow" onchange="updateTableFilter('tomorrow')">
            <option value="">All</option>
            {% for mod in modalities %}
            <option value="{{ mod|lower }}">{{ mod|upper }}</option>
            {% endfor %}
          </select>
        </div>
        <div class="filter-group">
          <label>Filter Skill</label>
          <select id="filter-skill-tomorrow" onchange="updateTableFilter('tomorrow')">
            <option value="">All</option>
            {% for skill in skills %}
            <option value="{{ skill }}">{{ skill }}</option>
            {% endfor %}
          </select>
        </div>
        <label class="filter-toggle">
          <input type="checkbox" id="filter-hide-zero-tomorrow" onchange="updateTableFilter('tomorrow')"> Hide 0/-1
        </label>
      </div>

      <!-- Worker Table - One row per entry -->
      <div class="table-container">
        <table class="edit-table compact-grid" id="edit-table-tomorrow">
          <thead id="table-head-tomorrow">
            <tr>
              <th>Worker</th>
              <th>Modality</th>
              <th>Shift</th>
              {% for skill in skills %}
              <th class="skill-cell">{{ skill }}</th>
              {% endfor %}
              <th>Task</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="table-body-tomorrow"></tbody>
        </table>
      </div>
      <div id="summary-tomorrow" class="summary-wrapper"></div>
      <p style="margin-top: 0.5rem; font-size: 0.75rem; color: #666;">★ = Worker has multiple entries (double shift)</p>
    </div>
  </div>

  <!-- Edit Modal -->
  <div class="modal-overlay" id="edit-modal">
    <div class="modal">
      <h3 id="modal-title">Edit Worker</h3>
      <div id="modal-content"></div>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveModalChanges()">Save</button>
      </div>
    </div>
  </div>

  <!-- Add Worker Modal -->
  <div class="modal-overlay" id="add-worker-modal">
    <div class="modal" style="max-width: 800px;">
      <h3 id="add-worker-modal-title">Add Worker</h3>
      <div id="add-worker-modal-content"></div>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="closeAddWorkerModal()">Cancel</button>
        <button class="btn btn-success" onclick="saveAddWorkerModal()">Add Worker</button>
      </div>
    </div>
  </div>

  <!-- Worker list datalist for autocomplete -->
  <datalist id="worker-list-datalist">
    {% for worker in worker_list %}
    <option value="{{ worker }}">
    {% endfor %}
  </datalist>

  <script>
    // Configuration from backend
    const SKILLS = {{ skills|default([])|tojson }};
    const MODALITIES = {{ modalities|default([])|tojson }};
    const MODALITY_SETTINGS = {{ modality_settings|default({})|tojson }};
    const SKILL_SETTINGS = {{ skill_settings|default({})|tojson }};
    const SHIFT_TIMES = {{ shift_times|default({})|tojson }};
    const WORKER_SKILLS = {{ worker_skills|default({})|tojson }};
    const TASK_ROLES = {{ task_roles|default([])|tojson }};
    const EXCLUSION_RULES = {{ exclusion_rules|default([])|tojson }};
    // Skill value display colors from config (active, passive, excluded, weighted)
    const SKILL_VALUE_COLORS = {{ skill_value_colors|default({})|tojson }};
    // UI theme colors from config
    const UI_COLORS = {{ ui_colors|default({})|tojson }};

    // Generate dynamic CSS for modality and skill colors from config
    (function() {
      const style = document.createElement('style');
      let css = '';
      // Modality colors
      for (const [mod, settings] of Object.entries(MODALITY_SETTINGS)) {
        const navColor = settings.nav_color || '#6c757d';
        const bgColor = settings.background_color || '#f8f9fa';
        css += `.badge-${mod} { background: ${navColor}; color: white; }\n`;
        css += `.modality-border-${mod} { border-color: ${navColor}; }\n`;
        css += `.modality-bg-${mod} { background: ${bgColor}; }\n`;
      }
      // Skill colors
      for (const [skill, settings] of Object.entries(SKILL_SETTINGS)) {
        const btnColor = settings.button_color || '#6c757d';
        const textColor = settings.text_color || '#ffffff';
        css += `.skill-header-${skill.toLowerCase()} { background: ${btnColor}; color: ${textColor}; }\n`;
        css += `.skill-btn-${skill.toLowerCase()} { background: ${btnColor}; color: ${textColor}; border: none; }\n`;
      }
      // Skill VALUE colors (1=active, 0=passive, -1=excluded, w=weighted)
      const activeColor = SKILL_VALUE_COLORS.active?.color || '#28a745';
      const passiveColor = SKILL_VALUE_COLORS.passive?.color || '#6c757d';
      const excludedColor = SKILL_VALUE_COLORS.excluded?.color || '#dc3545';
      const weightedColor = SKILL_VALUE_COLORS.weighted?.color || '#17a2b8';
      css += `.skill-val-1 { color: ${activeColor}; }\n`;
      css += `.skill-val-0 { color: ${passiveColor}; }\n`;
      css += `.skill-val--1 { color: ${excludedColor}; }\n`;
      css += `.skill-val-w { color: ${weightedColor}; }\n`;
      css += `.modifier-high { background: ${weightedColor}; color: white; }\n`;
      css += `.agg-has-weighted { color: ${weightedColor}; font-weight: bold; }\n`;
      // UI theme colors
      const todayColor = UI_COLORS.today_tab || '#28a745';
      const tomorrowColor = UI_COLORS.tomorrow_tab || '#ffc107';
      const successColor = UI_COLORS.success || '#28a745';
      const errorColor = UI_COLORS.error || '#dc3545';
      css += `.tab-btn.active-today { background: ${todayColor}; color: white; }\n`;
      css += `.today-banner { background: ${todayColor}15; border: 2px solid ${todayColor}; }\n`;
      css += `.today-banner h2, .today-banner p { color: ${todayColor}; }\n`;
      css += `.tab-btn.active-tomorrow { background: ${tomorrowColor}; color: #333; }\n`;
      css += `.tomorrow-banner { background: ${tomorrowColor}30; border: 2px solid ${tomorrowColor}; }\n`;
      css += `.tomorrow-banner h2, .tomorrow-banner p { color: #856404; }\n`;
      css += `.btn-success { background: ${successColor}; color: white; }\n`;
      css += `.btn-danger { background: ${errorColor}; color: white; }\n`;
      style.textContent = css;
      document.head.appendChild(style);
    })();

    // State
      let currentTab = 'today';
      let rawData = { today: {}, tomorrow: {} };  // Raw modality data
      let entriesData = { today: [], tomorrow: [] };  // Grouped by worker -> shifts (time-based)
      let workerCounts = { today: {}, tomorrow: {} };  // Count entries per worker for duplicate detection
      let currentEditEntry = null;
      let dataLoaded = { today: false, tomorrow: false };  // Track which tabs have been loaded
      let editMode = { today: true, tomorrow: true };  // Inline edit mode defaults to ON
      let pendingChanges = { today: {}, tomorrow: {} };  // Track unsaved inline changes
      let tableFilters = { today: { modality: '', skill: '', hideZero: false }, tomorrow: { modality: '', skill: '', hideZero: false } };
      let displayOrder = 'modality-first';  // 'modality-first' or 'skill-first'

      // Add Worker Modal state
      let addWorkerModalState = {
        tab: null,
        tasks: []  // Array of { task, modality, start_time, end_time, modifier, skills }
      };

      function toggleDisplayOrder() {
        displayOrder = displayOrder === 'modality-first' ? 'skill-first' : 'modality-first';
        const btn = document.getElementById('display-order-toggle');
        if (btn) {
          btn.textContent = displayOrder === 'modality-first' ? 'Mod → Skill' : 'Skill → Mod';
          btn.title = displayOrder === 'modality-first'
            ? 'Current: Modalities as groups, skills as sub-columns. Click to switch.'
            : 'Current: Skills as groups, modalities as sub-columns. Click to switch.';
        }
        renderTable('today');
        renderTable('tomorrow');
      }

      // Active skill values for filtering - excludes 0 and -1 (only shows explicitly active workers)
      const ACTIVE_SKILL_VALUES = new Set([1, '1', 'w', 'W']);

    function normalizeSkillValueJS(value) {
      if (value === undefined || value === null) return 0;
      if (value === 'w' || value === 'W') return 'w';
      if (typeof value === 'string' && value.trim() === '') return 0;
      const parsed = parseInt(value, 10);
      if (!isNaN(parsed) && parsed === 2) return 'w';
      return isNaN(parsed) ? value : parsed;
    }

    function isWeightedSkill(value) {
      return value === 'w' || value === 'W' || value === 2;
    }

    function displaySkillValue(value) {
      return isWeightedSkill(value) ? 'w' : value;
    }

    function isActiveSkillValue(value) {
      return ACTIVE_SKILL_VALUES.has(value);
    }

    // Check if skill value is non-negative (0, 1, or weighted)
    function isNonNegativeSkillValue(value) {
      const v = normalizeSkillValueJS(value);
      return v === 0 || v === 1 || isWeightedSkill(v);
    }

    // Helper: Get shifts (type='shift', non-exclusion)
    function getShiftRoles() {
      return TASK_ROLES.filter(t => t.type === 'shift' && !t.exclusion);
    }

    // Helper: Get gaps (type='gap', exclusion=true)
    function getGapTasks() {
      return TASK_ROLES.filter(t => t.type === 'gap' || t.exclusion);
    }

    // Helper: Check if a task name is a gap (using config, not string matching)
    function isGapTask(taskName) {
      if (!taskName) return false;
      const gapTasks = getGapTasks();
      const taskLower = taskName.toLowerCase().trim();
      return gapTasks.some(g => g.name && g.name.toLowerCase().trim() === taskLower);
    }

    // Helper: Render task/role dropdown with optgroups for Shifts vs Gaps
    function renderTaskOptionsWithGroups(selectedValue = '', includeGaps = false) {
      const shifts = getShiftRoles();
      const gaps = getGapTasks();

      let html = '<option value="">-- Select --</option>';

      // Shifts/Roles group
      if (shifts.length > 0) {
        html += '<optgroup label="Shifts / Roles">';
        shifts.forEach(t => {
          const selected = t.name === selectedValue ? 'selected' : '';
          const dataAttrs = `data-type="shift" data-modalities='${JSON.stringify(t.modalities || [])}' data-shift="${escapeHtml(t.shift || 'Fruehdienst')}" data-skills='${JSON.stringify(t.base_skills || {})}' data-modifier="${t.modifier || 1.0}"`;
          html += `<option value="${escapeHtml(t.name)}" ${dataAttrs} ${selected}>${escapeHtml(t.name)}</option>`;
        });
        html += '</optgroup>';
      }

      // Gaps/Tasks group (optional)
      if (includeGaps && gaps.length > 0) {
        html += '<optgroup label="Tasks / Gaps (makes -1)">';
        gaps.forEach(t => {
          const selected = t.name === selectedValue ? 'selected' : '';
          const dataAttrs = `data-type="gap" data-schedule='${JSON.stringify(t.schedule || {})}' data-exclusion="true"`;
          html += `<option value="${escapeHtml(t.name)}" ${dataAttrs} ${selected}>${escapeHtml(t.name)}</option>`;
        });
        html += '</optgroup>';
      }

      return html;
    }

    // Get CSS class for skill value display
    function getSkillClass(value) {
      const v = normalizeSkillValueJS(value);
      if (v === 1) return 'skill-val-1';
      if (v === 0) return 'skill-val-0';
      if (v === -1) return 'skill-val--1';
      if (isWeightedSkill(v)) return 'skill-val-w';
      return '';
    }

    // Get color for skill value based on config
    function getSkillColor(value) {
      const v = normalizeSkillValueJS(value);
      if (v === 1) return SKILL_VALUE_COLORS.active?.color || '#28a745';
      if (v === 0) return SKILL_VALUE_COLORS.passive?.color || '#6c757d';
      if (v === -1) return SKILL_VALUE_COLORS.excluded?.color || '#dc3545';
      if (isWeightedSkill(v)) return SKILL_VALUE_COLORS.weighted?.color || '#17a2b8';
      return SKILL_VALUE_COLORS.passive?.color || '#ddd';
    }

    function shiftMatchesFilters(shift, filter) {
      if (!filter) return true;
      const { modality, skill, hideZero } = filter;
      const filterActive = Boolean(modality || skill || hideZero);
      if (!filterActive) return true;

      const modalitiesToCheck = modality ? [modality] : MODALITIES.map(m => m.toLowerCase());
      let matchFound = false;

      for (const modKey of modalitiesToCheck) {
        const modData = shift.modalities[modKey];
        if (!modData) continue;

        if (skill) {
          const val = modData.skills[skill];
          if (hideZero ? isActiveSkillValue(val) : val !== undefined) {
            matchFound = true;
            break;
          }
        } else {
          const hasSkill = SKILLS.some(s => {
            const val = modData.skills[s];
            return hideZero ? isActiveSkillValue(val) : val !== undefined;
          });
          if (hasSkill) {
            matchFound = true;
            break;
          }
        }
      }

      return matchFound;
    }

    function updateTableFilter(tab) {
      const modality = (document.getElementById(`filter-modality-${tab}`)?.value || '').toLowerCase();
      const skill = document.getElementById(`filter-skill-${tab}`)?.value || '';
      const hideZero = document.getElementById(`filter-hide-zero-${tab}`)?.checked || false;
      tableFilters[tab] = { modality, skill, hideZero };
      renderTable(tab);
    }

    function applyEditModeUI(tab) {
      // Update button
      const btn = document.getElementById(`edit-mode-btn-${tab}`);
      if (btn) {
        btn.textContent = editMode[tab] ? 'Exit Edit Mode' : 'Quick Edit';
        btn.className = editMode[tab] ? 'btn btn-warning' : 'btn btn-secondary';
      }

      // Show/hide save button
      const saveBtn = document.getElementById(`save-inline-btn-${tab}`);
      if (saveBtn) {
        saveBtn.style.display = editMode[tab] ? 'inline-block' : 'none';
        const count = Object.keys(pendingChanges[tab] || {}).length;
        saveBtn.textContent = count > 0 ? `Save ${count} change${count > 1 ? 's' : ''}` : 'Save Changes';
      }
    }

    // Toggle inline edit mode
    function toggleEditMode(tab) {
      editMode[tab] = !editMode[tab];
      pendingChanges[tab] = {};  // Reset pending changes
      applyEditModeUI(tab);
      renderTable(tab);
    }

    // Track inline skill change (supports adding new modalities with rowIndex=-1)
    function onInlineSkillChange(tab, modKey, rowIndex, skill, value, groupIdx, shiftIdx, el = null) {
      const normalizedVal = normalizeSkillValueJS(value);

      // Handle new modality additions (rowIndex = -1)
      if (rowIndex === -1) {
        const key = `new-${groupIdx}-${shiftIdx}-${modKey}`;
        if (!pendingChanges[tab][key]) {
          pendingChanges[tab][key] = { modality: modKey, row_index: -1, groupIdx, shiftIdx, isNew: true, updates: {} };
        }
        pendingChanges[tab][key].updates[skill] = normalizedVal;
        if (isWeightedSkill(normalizedVal)) {
          const currentWeight = el?.nextElementSibling ? parseFloat(el.nextElementSibling.value || '1.0') : 1.0;
          pendingChanges[tab][key].updates['Modifier'] = currentWeight;
        } else {
          delete pendingChanges[tab][key].updates['Modifier'];
        }
      } else {
        const key = `${modKey}-${rowIndex}`;
        if (!pendingChanges[tab][key]) {
          pendingChanges[tab][key] = { modality: modKey, row_index: rowIndex, updates: {} };
        }
        pendingChanges[tab][key].updates[skill] = normalizedVal;
        if (isWeightedSkill(normalizedVal)) {
          const currentWeight = el?.nextElementSibling ? parseFloat(el.nextElementSibling.value || '1.0') : 1.0;
          pendingChanges[tab][key].updates['Modifier'] = currentWeight;
        } else {
          delete pendingChanges[tab][key].updates['Modifier'];
        }
      }

      if (el && el.nextElementSibling) {
        el.nextElementSibling.style.display = isWeightedSkill(normalizedVal) ? '' : 'none';
      }

      // Update save button count
      const count = Object.keys(pendingChanges[tab]).length;
      const saveBtn = document.getElementById(`save-inline-btn-${tab}`);
      if (saveBtn) {
        saveBtn.textContent = `Save ${count} change${count > 1 ? 's' : ''}`;
      }
    }

    // Track inline modifier change per modality
    function onInlineModifierChange(tab, modKey, rowIndex, value, groupIdx, shiftIdx) {
      const parsed = parseFloat(value) || 1.0;

      if (rowIndex === -1) {
        // New modality addition
        const key = `new-${groupIdx}-${shiftIdx}-${modKey}`;
        if (!pendingChanges[tab][key]) {
          pendingChanges[tab][key] = { modality: modKey, row_index: -1, groupIdx, shiftIdx, isNew: true, updates: {} };
        }
        pendingChanges[tab][key].updates['Modifier'] = parsed;
      } else {
        const key = `${modKey}-${rowIndex}`;
        if (!pendingChanges[tab][key]) {
          pendingChanges[tab][key] = { modality: modKey, row_index: rowIndex, updates: {} };
        }
        pendingChanges[tab][key].updates['Modifier'] = parsed;
      }

      // Update save button count
      const count = Object.keys(pendingChanges[tab]).length;
      const saveBtn = document.getElementById(`save-inline-btn-${tab}`);
      if (saveBtn) {
        saveBtn.textContent = `Save ${count} change${count > 1 ? 's' : ''}`;
      }
    }

    // Valid skill values for quick edit validation
    const VALID_SKILL_VALUES = ['-1', '0', '1', 'w', 'W'];
    const VALID_MODIFIER_VALUES = [0.5, 0.75, 1, 1.0, 1.25, 1.5];

    // Validate and save skill input on blur
    function validateAndSaveSkill(el) {
      const raw = (el.value || '').trim().toLowerCase();
      let normalized;

      // Validate input - only allow -1, 0, 1, w
      if (raw === '-1' || raw === '-') normalized = -1;
      else if (raw === '0' || raw === '') normalized = 0;
      else if (raw === '1') normalized = 1;
      else if (raw === 'w' || raw === '2') normalized = 'w';
      else {
        // Invalid - reset to 0
        normalized = 0;
        showMessage('error', 'Valid values: -1, 0, 1, w');
      }

      // Update display
      el.value = displaySkillValue(normalized);
      const color = getSkillColor(normalized);
      el.style.backgroundColor = color + '20';
      el.style.borderColor = color;

      // Trigger change tracking
      const { tab, mod, row, skill, gidx, sidx } = el.dataset;
      onInlineSkillChange(tab, mod, parseInt(row), skill, normalized, parseInt(gidx), parseInt(sidx), el);
    }

    // Handle keyboard shortcuts for skill input
    function handleSkillKeydown(event, el) {
      if (event.key === 'Enter') {
        el.blur();
        event.preventDefault();
      } else if (event.key === 'Tab') {
        // Allow normal tab behavior
      } else if (event.key === 'ArrowUp') {
        // Cycle: -1 -> 0 -> 1 -> w -> -1
        const val = normalizeSkillValueJS(el.value);
        let next;
        if (val === -1) next = 0;
        else if (val === 0) next = 1;
        else if (val === 1) next = 'w';
        else next = -1;
        el.value = displaySkillValue(next);
        validateAndSaveSkill(el);
        event.preventDefault();
      } else if (event.key === 'ArrowDown') {
        // Cycle reverse: w -> 1 -> 0 -> -1 -> w
        const val = normalizeSkillValueJS(el.value);
        let next;
        if (isWeightedSkill(val)) next = 1;
        else if (val === 1) next = 0;
        else if (val === 0) next = -1;
        else next = 'w';
        el.value = displaySkillValue(next);
        validateAndSaveSkill(el);
        event.preventDefault();
      }
    }

    // Validate and save modifier input on blur (per-modality - legacy)
    function validateAndSaveModifier(el) {
      let parsed = parseFloat(el.value);

      // Validate - clamp to valid range
      if (isNaN(parsed) || parsed < 0.5) parsed = 0.5;
      else if (parsed > 1.5) parsed = 1.5;

      // Round to nearest valid value
      const validValues = [0.5, 0.75, 1.0, 1.25, 1.5];
      parsed = validValues.reduce((prev, curr) =>
        Math.abs(curr - parsed) < Math.abs(prev - parsed) ? curr : prev
      );

      el.value = parsed;

      // Trigger change tracking
      const { tab, mod, row, gidx, sidx } = el.dataset;
      onInlineModifierChange(tab, mod, parseInt(row), parsed, parseInt(gidx), parseInt(sidx));
    }

    // Validate and save shift-level modifier (applies to all modalities in the shift)
    function validateAndSaveShiftModifier(el) {
      let parsed = parseFloat(el.value);

      // Validate - clamp to valid range
      if (isNaN(parsed) || parsed < 0.5) parsed = 0.5;
      else if (parsed > 1.5) parsed = 1.5;

      // Round to nearest valid value
      const validValues = [0.5, 0.75, 1.0, 1.25, 1.5];
      parsed = validValues.reduce((prev, curr) =>
        Math.abs(curr - parsed) < Math.abs(prev - parsed) ? curr : prev
      );

      el.value = parsed;

      // Trigger change tracking for ALL modalities in this shift
      const { tab, gidx, sidx } = el.dataset;
      onInlineShiftModifierChange(tab, parseInt(gidx), parseInt(sidx), parsed);

      // Update save button count
      const count = Object.keys(pendingChanges[tab]).length;
      const saveBtn = document.getElementById(`save-inline-btn-${tab}`);
      if (saveBtn) {
        saveBtn.textContent = `Save ${count} change${count > 1 ? 's' : ''}`;
      }
    }

    // Handle keyboard for modifier input
    function handleModKeydown(event, el) {
      // Determine if this is shift-level (no mod attribute) or modality-level modifier
      const isShiftLevel = !el.dataset.mod;
      const saveFunction = isShiftLevel ? validateAndSaveShiftModifier : validateAndSaveModifier;

      if (event.key === 'Enter') {
        el.blur();
        event.preventDefault();
      } else if (event.key === 'ArrowUp') {
        const val = parseFloat(el.value) || 1.0;
        const validValues = [0.5, 0.75, 1.0, 1.25, 1.5];
        const idx = validValues.indexOf(val);
        const next = idx < validValues.length - 1 ? validValues[idx + 1] : validValues[validValues.length - 1];
        el.value = next;
        saveFunction(el);
        event.preventDefault();
      } else if (event.key === 'ArrowDown') {
        const val = parseFloat(el.value) || 1.0;
        const validValues = [0.5, 0.75, 1.0, 1.25, 1.5];
        const idx = validValues.indexOf(val);
        const next = idx > 0 ? validValues[idx - 1] : validValues[0];
        el.value = next;
        saveFunction(el);
        event.preventDefault();
      }
    }

    // Save all inline changes (handles both updates and new modality additions)
    async function saveInlineChanges(tab) {
      const changes = Object.values(pendingChanges[tab]);
      if (changes.length === 0) {
        showMessage('error', 'No changes to save');
        return;
      }

      const updateEndpoint = tab === 'today' ? '/api/live-schedule/update-row' : '/api/prep-next-day/update-row';
      const addEndpoint = tab === 'today' ? '/api/live-schedule/add-worker' : '/api/prep-next-day/add-worker';

      try {
        for (const change of changes) {
          if (change.isNew) {
            // New modality addition - need to add via add-worker endpoint
            const group = entriesData[tab][change.groupIdx];
            const shift = group?.shiftsArray?.[change.shiftIdx];
            if (!group || !shift) continue;

            // Only add if any skill is set to 0/1/w (skip pure -1 placeholders)
            const hasActiveSkill = SKILLS.some(skill => {
              const val = change.updates[skill];
              return val !== undefined && isNonNegativeSkillValue(val);
            });
            if (!hasActiveSkill) continue;

            // Build worker_data for the new modality
            const workerData = {
              PPL: group.worker,
              start_time: shift.start_time,
              end_time: shift.end_time,
              Modifier: change.updates.Modifier || 1.0,
              tasks: shift.task || ''
            };
            // Add all skills (use -1 as default for unspecified)
            SKILLS.forEach(skill => {
              workerData[skill] = change.updates[skill] !== undefined ? change.updates[skill] : -1;
            });

            const response = await fetch(addEndpoint, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ modality: change.modality, worker_data: workerData })
            });

            if (!response.ok) {
              const result = await response.json();
              console.warn(`Failed to add ${change.modality}: ${result.error}`);
            }
          } else {
            // Existing entry update
            const response = await fetch(updateEndpoint, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(change)
            });

            if (!response.ok) {
              const result = await response.json();
              throw new Error(result.error || 'Failed to update');
            }
          }
        }

        showMessage('success', `Saved ${changes.length} change${changes.length > 1 ? 's' : ''}`);
        pendingChanges[tab] = {};
        applyEditModeUI(tab);
        await loadData();
      } catch (error) {
        showMessage('error', error.message);
      }
    }

    // Calculate aggregated proficiency class for a set of values
    // Priority: Positive (1) values lead the coloring over negative (-1) values
    function getAggregatedClass(values) {
      if (!values || values.length === 0) return 'agg-mixed';

      const normalized = values.map(v => normalizeSkillValueJS(v));
      const allOne = normalized.every(v => v === 1 || isWeightedSkill(v));  // Include weighted/freshman
      const anyOne = normalized.some(v => v === 1 || isWeightedSkill(v));
      const allZero = normalized.every(v => v === 0);
      const anyZero = normalized.some(v => v === 0);
      const allNeg = normalized.every(v => v === -1);

      // Positive values take priority - if any positive, show green colors
      if (allOne) return 'agg-all-1';
      if (anyOne) return 'agg-any-1';  // Any positive wins over negatives
      if (allZero) return 'agg-all-0';
      if (anyZero) return 'agg-any-0';
      if (allNeg) return 'agg-all-neg';
      return 'agg-mixed';
    }

    // Get display value for aggregated cell
    function getAggregatedDisplay(values) {
      if (!values || values.length === 0) return '-';
      const normalized = values.map(v => normalizeSkillValueJS(v));
      const allSame = normalized.every(v => v === normalized[0]);
      if (allSame) return displaySkillValue(normalized[0]);
      // Show unique values sorted (w/1, 0, -1)
      const unique = [...new Set(normalized)].sort((a, b) => {
        const aVal = isWeightedSkill(a) ? 1 : a;
        const bVal = isWeightedSkill(b) ? 1 : b;
        return bVal - aVal;
      });
      return unique.map(displaySkillValue).join('/');
    }

    // Check if values contain weighted entries (skill='w')
    function hasWeightedEntries(values) {
      return values && values.some(v => isWeightedSkill(v));
    }

    // Utility: Escape HTML to prevent XSS
    function escapeHtml(text) {
      if (text === null || text === undefined) return '';
      const div = document.createElement('div');
      div.textContent = String(text);
      return div.innerHTML;
    }

    // Tab switching with lazy loading
    async function switchTab(tab) {
      const previousTab = currentTab;
      currentTab = tab;
      document.getElementById('tab-today').className = tab === 'today' ? 'tab-btn active-today' : 'tab-btn';
      document.getElementById('tab-tomorrow').className = tab === 'tomorrow' ? 'tab-btn active-tomorrow' : 'tab-btn';
      document.getElementById('content-today').className = tab === 'today' ? 'tab-content active' : 'tab-content';
      document.getElementById('content-tomorrow').className = tab === 'tomorrow' ? 'tab-content active' : 'tab-content';

      // Preserve filter state when switching tabs
      if (previousTab && previousTab !== tab) {
        const prevFilter = tableFilters[previousTab];
        if (prevFilter) {
          // Copy filter state to new tab
          tableFilters[tab] = { ...prevFilter };

          // Update UI dropdowns for new tab
          const modalitySelect = document.getElementById(`filter-modality-${tab}`);
          const skillSelect = document.getElementById(`filter-skill-${tab}`);
          const hideZeroCheckbox = document.getElementById(`filter-hide-zero-${tab}`);

          if (modalitySelect && prevFilter.modality !== undefined) {
            modalitySelect.value = prevFilter.modality;
          }
          if (skillSelect && prevFilter.skill !== undefined) {
            skillSelect.value = prevFilter.skill;
          }
          if (hideZeroCheckbox && prevFilter.hideZero !== undefined) {
            hideZeroCheckbox.checked = prevFilter.hideZero;
          }
        }
      }

      // Lazy load data for the selected tab if not already loaded
      if (!dataLoaded[tab]) {
        await loadTabData(tab);
      }
    }

    // Load data for a specific tab (lazy loading)
    async function loadTabData(tab) {
      try {
        const endpoint = tab === 'today' ? '/api/live-schedule/data' : '/api/prep-next-day/data';
        const response = await fetch(endpoint);

        if (!response.ok) {
          const text = await response.text();
          console.error(`${tab} API error:`, text);
          rawData[tab] = {};
          dataLoaded[tab] = false;
          return;
        }

        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
          rawData[tab] = await response.json();
        } else {
          console.error(`${tab} API returned non-JSON`);
          rawData[tab] = {};
          dataLoaded[tab] = false;
          return;
        }

        const result = buildEntriesByWorker(rawData[tab]);
        entriesData[tab] = result.entries;
        workerCounts[tab] = result.counts;
        dataLoaded[tab] = true;

        renderTable(tab);
      } catch (error) {
        console.error(`Load error for ${tab}:`, error);
        showMessage('error', `Error loading ${tab} data: ${error.message}`);
        dataLoaded[tab] = false;
      }
    }

    // Load data for both tabs (used after mutations)
    async function loadData() {
      // Reset loaded flags to force refresh
      dataLoaded.today = false;
      dataLoaded.tomorrow = false;

      // Load current tab first (visible to user)
      await loadTabData(currentTab);

      // Load other tab in background
      const otherTab = currentTab === 'today' ? 'tomorrow' : 'today';
      loadTabData(otherTab);  // Don't await - load in background
    }

    // Build grouped entries list: worker -> shifts (time-based) -> modality×skills matrix
    // Each shift is a unique time slot that can have multiple modalities
    function buildEntriesByWorker(data) {
      const counts = {};
      const grouped = {};

      // First pass: collect all entries
      MODALITIES.forEach(mod => {
        const modData = Array.isArray(data[mod]) ? data[mod] : [];
        modData.forEach(row => {
          const workerName = row.PPL;
          counts[workerName] = (counts[workerName] || 0) + 1;

          // Parse task - handle both string and array formats
          let taskStr = row.tasks || '';
          if (Array.isArray(taskStr)) {
            taskStr = taskStr.filter(t => t && t.trim()).join(', ');
          }

          // Check if this is a gap row using config (not string matching)
          const isGapRow = isGapTask(taskStr);

          const rosterPreset = (WORKER_SKILLS[workerName] || {});
          const rosterSkills = rosterPreset[mod] || rosterPreset.default || {};

          const entry = {
            worker: workerName,
            modality: mod,
            row_index: row.row_index,
            start_time: row.start_time || '07:00',
            end_time: row.end_time || '15:00',
            modifier: row.Modifier !== undefined ? row.Modifier : 1.0,
            skills: SKILLS.reduce((acc, skill) => {
              if (isGapRow) { acc[skill] = -1; return acc; }
              const rawVal = row[skill];
              const hasRaw = rawVal !== undefined && rawVal !== '';
              const fallback = rosterSkills[skill];
              const hasFallback = fallback !== undefined && fallback !== '';

              const normalizedRaw = hasRaw ? normalizeSkillValueJS(rawVal) : undefined;
              const normalizedFallback = hasFallback ? normalizeSkillValueJS(fallback) : undefined;

              acc[skill] = hasRaw
                ? normalizedRaw
                : (hasFallback ? normalizedFallback : 0);
              return acc;
            }, {}),
            task: taskStr
          };

          if (!grouped[workerName]) {
            grouped[workerName] = { worker: workerName, shifts: {}, allEntries: [] };
          }
          grouped[workerName].allEntries.push(entry);

          // Group by time slot (shift key = start_time-end_time)
          const shiftKey = `${entry.start_time}-${entry.end_time}`;
          if (!grouped[workerName].shifts[shiftKey]) {
            grouped[workerName].shifts[shiftKey] = {
              start_time: entry.start_time,
              end_time: entry.end_time,
              modifier: entry.modifier,
              task: entry.task,
              modalities: {}  // modality -> {skills, row_index}
            };
          }

          // Add this modality's skills to the shift
          const modKey = mod.toLowerCase();
          grouped[workerName].shifts[shiftKey].modalities[modKey] = {
            skills: entry.skills,
            row_index: entry.row_index,
            modifier: entry.modifier
          };

          // Merge tasks if different
          const existingTask = grouped[workerName].shifts[shiftKey].task;
          if (entry.task && existingTask && !existingTask.includes(entry.task)) {
            grouped[workerName].shifts[shiftKey].task = existingTask + ', ' + entry.task;
          } else if (entry.task && !existingTask) {
            grouped[workerName].shifts[shiftKey].task = entry.task;
          }
        });
      });

      // Ensure every shift carries all modalities so inline+modal edits can add missing ones
      Object.values(grouped).forEach(group => {
        const preset = WORKER_SKILLS[group.worker] || {};
        Object.values(group.shifts).forEach(shift => {
          MODALITIES.map(m => m.toLowerCase()).forEach(modKey => {
            if (!shift.modalities[modKey]) {
              const skills = {};
              // Default placeholders to -1 so new modality rows are opt-in
              const rosterDefaults = preset[modKey] || preset.default || {};
              SKILLS.forEach(skill => {
                const fallback = rosterDefaults[skill];
                skills[skill] = fallback !== undefined ? fallback : -1;
              });
              shift.modalities[modKey] = {
                skills,
                row_index: -1,
                modifier: shift.modifier || 1.0,
                placeholder: true
              };
            }
          });
        });
      });

      // Convert shifts object to sorted array and sort workers
      const entries = Object.values(grouped).map(group => {
        group.shiftsArray = Object.entries(group.shifts)
          .map(([key, shift]) => ({ ...shift, shiftKey: key }))
          .sort((a, b) => (a.start_time || '').localeCompare(b.start_time || ''));
        return group;
      }).sort((a, b) => a.worker.localeCompare(b.worker));

      return { entries, counts };
    }

    // Render table header - supports both modality-first and skill-first display orders
    function renderTableHeader(tab) {
      const thead = document.getElementById(`table-head-${tab}`);
      const isEditMode = editMode[tab];
      const modalKeys = MODALITIES.map(m => m.toLowerCase());

      let headerHtml = '<tr class="header-top">';
      headerHtml += '<th rowspan="2" class="worker-col">Worker</th>';
      headerHtml += `<th rowspan="2" class="shift-col">${isEditMode ? 'Shift (editable)' : 'Shift'}</th>`;
      headerHtml += '<th rowspan="2" class="task-col">Task</th>';

      if (displayOrder === 'modality-first') {
        // Modalities as top-level columns (each spanning skill count)
        modalKeys.forEach(mod => {
          const modSettings = MODALITY_SETTINGS[mod] || {};
          const label = (modSettings.label || mod).toUpperCase();
          const navColor = modSettings.nav_color || '#6c757d';
          headerHtml += `<th colspan="${SKILLS.length}" class="skill-header" style="background:${navColor}; color:#fff;">${label}</th>`;
        });
      } else {
        // Skills as top-level columns (each spanning modality count)
        SKILLS.forEach(skill => {
          const skillSettings = SKILL_SETTINGS[skill] || {};
          const btnColor = skillSettings.button_color || '#6c757d';
          const textColor = skillSettings.text_color || '#ffffff';
          headerHtml += `<th colspan="${modalKeys.length}" class="skill-header" style="background:${btnColor}; color:${textColor};">${escapeHtml(skill)}</th>`;
        });
      }

      headerHtml += '<th rowspan="2" class="modifier-col">Mod.</th>';
      headerHtml += '<th rowspan="2">Actions</th>';
      headerHtml += '</tr>';

      // Second header row: sub-columns
      headerHtml += '<tr class="header-sub">';
      if (displayOrder === 'modality-first') {
        // Skill labels under each modality
        modalKeys.forEach(() => {
          SKILLS.forEach(skill => {
            const shortLabel = skill.substring(0, 3);
            headerHtml += `<th class="sub-col">${shortLabel}</th>`;
          });
        });
      } else {
        // Modality labels under each skill
        SKILLS.forEach(() => {
          modalKeys.forEach(mod => {
            const modSettings = MODALITY_SETTINGS[mod] || {};
            const label = (modSettings.label || mod).replace(/-/g, '');
            const shortLabel = label.substring(0, 2).toUpperCase();
            headerHtml += `<th class="sub-col">${shortLabel}</th>`;
          });
        });
      }

      headerHtml += '</tr>';

      thead.innerHTML = headerHtml;
    }

    // Render grouped table by worker - one row per modality entry with skill columns
    // Shows ALL modalities for each shift (even those with -1)
    function renderSummary(tab, groups) {
      const summaryEl = document.getElementById(`summary-${tab}`);
      if (!summaryEl) return;

      const counts = {};
      SKILLS.forEach(skill => {
        counts[skill] = {};
        MODALITIES.forEach(mod => counts[skill][mod.toLowerCase()] = 0);
      });

      groups.forEach(group => {
        const shifts = group.shiftsArray || [];
        SKILLS.forEach(skill => {
          MODALITIES.forEach(mod => {
            const modKey = mod.toLowerCase();
            const hasActive = shifts.some(shift => {
              const modData = shift.modalities[modKey];
              if (!modData) return false;
              const val = modData.skills[skill];
              return isActiveSkillValue(val);
            });
            if (hasActive) {
              counts[skill][modKey] += 1;
            }
          });
        });
      });

      let html;
      if (displayOrder === 'modality-first') {
        html = '<div class="summary-title">Active counts by modality & skill (w and 1 counted once per worker)</div>';
        html += '<table class="summary-table"><thead><tr><th>Modality</th>';
        SKILLS.forEach(skill => {
          html += `<th>${escapeHtml(skill)}</th>`;
        });
        html += '</tr></thead><tbody>';

        MODALITIES.forEach(mod => {
          const modSettings = MODALITY_SETTINGS[mod.toLowerCase()] || {};
          const navColor = modSettings.nav_color || '#6c757d';
          html += `<tr><td style="text-align:left; font-weight:600; background:${navColor}20;">${mod.toUpperCase()}</td>`;
          SKILLS.forEach(skill => {
            html += `<td>${counts[skill][mod.toLowerCase()]}</td>`;
          });
          html += '</tr>';
        });
      } else {
        html = '<div class="summary-title">Active counts by skill & modality (w and 1 counted once per worker)</div>';
        html += '<table class="summary-table"><thead><tr><th>Skill</th>';
        MODALITIES.forEach(mod => {
          html += `<th>${mod.toUpperCase()}</th>`;
        });
        html += '</tr></thead><tbody>';

        SKILLS.forEach(skill => {
          const skillSettings = SKILL_SETTINGS[skill] || {};
          const btnColor = skillSettings.button_color || '#6c757d';
          html += `<tr><td style="text-align:left; font-weight:600; background:${btnColor}20;">${escapeHtml(skill)}</td>`;
          MODALITIES.forEach(mod => {
            html += `<td>${counts[skill][mod.toLowerCase()]}</td>`;
          });
          html += '</tr>';
        });
      }

      html += '</tbody></table>';
      summaryEl.innerHTML = html;
    }

    function renderTable(tab) {
      // First update the header
      renderTableHeader(tab);

      const tbody = document.getElementById(`table-body-${tab}`);
      tbody.innerHTML = '';

      const groups = entriesData[tab];
      const isEditMode = editMode[tab];
      const filter = tableFilters[tab] || {};
      const filterActive = Boolean(filter.modality || filter.skill || filter.hideZero);
      const visibleGroups = [];

      const modCount = MODALITIES.length;
      // Calculate column count: Worker + Shift + Task + (Skills × Modalities) + 1 Modifier + Actions
      const colCount = 3 + (SKILLS.length * modCount) + 1 + 1;

      if (!groups || groups.length === 0) {
        tbody.innerHTML = `<tr><td colspan="${colCount}" style="text-align: center; padding: 2rem; color: #666;">No data. Load from CSV first.</td></tr>`;
        renderSummary(tab, []);
        return;
      }

      groups.forEach((group, gIdx) => {
        const shifts = group.shiftsArray || [];
        if (shifts.length === 0) return;

        const shiftsToRender = filterActive ? shifts.filter(shift => shiftMatchesFilters(shift, filter)) : shifts;
        if (filterActive && shiftsToRender.length === 0) return;

        const escapedWorker = escapeHtml(group.worker);

        const totalRows = shiftsToRender.length;
        const isDuplicate = shifts.length > 1;
        const duplicateBadge = isDuplicate ? `<span class="duplicate-badge">${shifts.length} shifts</span>` : '';

        shiftsToRender.forEach((shift, shiftIdx) => {
          const tr = document.createElement('tr');
          const modKeysToShow = MODALITIES.map(m => m.toLowerCase());

          if (shiftIdx === 0) {
            tr.classList.add('worker-group-first');
            tr.innerHTML += `<td rowspan="${totalRows}" style="vertical-align: middle;"><span class="worker-name ${isDuplicate ? 'duplicate' : ''}">${escapedWorker}</span>${duplicateBadge}</td>`;
          }

          if (isEditMode) {
            const shiftEditor = `<div style="display:flex; gap:0.25rem; align-items:center;">
                <input type="time" value="${shift.start_time || '07:00'}" onchange="onInlineTimeChange('${tab}', ${gIdx}, ${shiftIdx}, 'start', this.value)" style="padding: 0.15rem; font-size: 0.75rem; width: 70px;">
                -
                <input type="time" value="${shift.end_time || '15:00'}" onchange="onInlineTimeChange('${tab}', ${gIdx}, ${shiftIdx}, 'end', this.value)" style="padding: 0.15rem; font-size: 0.75rem; width: 70px;">
              </div>`;
            tr.innerHTML += `<td class="grid-cell shift-col">${shiftEditor}</td>`;
          } else {
            const gapInfo = (shift.gaps || []).map(g => `${escapeHtml(g.type || 'Gap')}: ${escapeHtml(g.start || '')}-${escapeHtml(g.end || '')}`).join('<br>');
            const shiftLabel = `<div><strong>${escapeHtml(shift.start_time || '')}-${escapeHtml(shift.end_time || '')}</strong></div>`;
            tr.innerHTML += `<td class="grid-cell shift-col">${shiftLabel}${gapInfo ? `<div style="font-size:0.7rem;color:#555;">${gapInfo}</div>` : ''}</td>`;
          }

          const taskStr = shift.task || '';
          tr.innerHTML += `<td class="grid-cell task-col">${taskStr ? `<span class="task-badge">${escapeHtml(taskStr)}</span>` : '<span style="color:#aaa;">-</span>'}</td>`;

          // Render data cells based on display order
          const renderCell = (modKey, skill) => {
            const modData = shift.modalities[modKey] || { skills: {}, row_index: -1, modifier: 1.0 };
            const isAssigned = modData.row_index !== undefined && modData.row_index >= 0;
            const isGap = (shift.gaps || []).length > 0 || isGapTask(shift.task);
            const rawVal = isGap ? -1 : (modData.skills[skill] !== undefined ? modData.skills[skill] : -1);
            const val = normalizeSkillValueJS(rawVal);

            // Get modality background color for visual "lanes"
            const modSettings = MODALITY_SETTINGS[modKey] || {};
            const modBgColor = modSettings.background_color || '#fff';
            const cellBg = isAssigned ? modBgColor : '#fafafa';
            const cellClass = `grid-cell ${isAssigned ? '' : 'ghost'}`;

            const displayVal = displaySkillValue(val);
            const skillClass = getSkillClass(val);
            const skillColor = getSkillColor(val);
            if (isEditMode) {
              return `<td class="${cellClass}" style="background:${cellBg};">
                <input type="text" class="grid-input" value="${displayVal}"
                  data-tab="${tab}" data-mod="${modKey}" data-row="${modData.row_index}"
                  data-skill="${skill}" data-gidx="${gIdx}" data-sidx="${shiftIdx}"
                  onblur="validateAndSaveSkill(this)" onkeydown="handleSkillKeydown(event, this)"
                  style="background:${skillColor}20;">
              </td>`;
            } else {
              return `<td class="${cellClass}" style="background:${cellBg};"><span class="grid-badge skill-val ${skillClass}">${displayVal}</span></td>`;
            }
          };

          if (displayOrder === 'modality-first') {
            modKeysToShow.forEach(modKey => {
              SKILLS.forEach(skill => {
                tr.innerHTML += renderCell(modKey, skill);
              });
            });
          } else {
            SKILLS.forEach(skill => {
              modKeysToShow.forEach(modKey => {
                tr.innerHTML += renderCell(modKey, skill);
              });
            });
          }

          // Single modifier column for entire shift (applies to all modalities)
          const hasAnyAssigned = modKeysToShow.some(modKey => {
            const modData = shift.modalities[modKey];
            return modData && modData.row_index !== undefined && modData.row_index >= 0;
          });
          const hasAnyWeighted = modKeysToShow.some(modKey => {
            const modData = shift.modalities[modKey];
            return modData && Object.values(modData.skills || {}).some(v => isWeightedSkill(v));
          });
          const modVal = shift.modifier || 1.0;
          const modCellClass = `grid-cell grid-modifier ${hasAnyAssigned ? '' : 'ghost'}`;
          const modClass = hasAnyWeighted ? 'modifier-high' : (modVal < 1 ? 'modifier-low' : '');
          if (isEditMode) {
            tr.innerHTML += `<td class="${modCellClass}">
              <input type="text" class="grid-mod-input" value="${modVal}"
                data-tab="${tab}" data-gidx="${gIdx}" data-sidx="${shiftIdx}"
                onblur="validateAndSaveShiftModifier(this)" onkeydown="handleModKeydown(event, this)">
            </td>`;
          } else {
            tr.innerHTML += `<td class="${modCellClass}"><span class="modifier-badge ${modClass}">${modVal.toFixed(2)}x</span></td>`;
          }

          if (shiftIdx === 0) {
            tr.innerHTML += `
              <td rowspan="${totalRows}" class="action-cell" style="vertical-align: middle;">
                <button class="btn btn-small btn-primary" onclick="openEditModal('${tab}', ${gIdx})" title="Edit">Edit</button>
                <button class="btn btn-small btn-danger" onclick="deleteWorkerEntries('${tab}', ${gIdx})" title="Delete All">Del</button>
              </td>`;
          }

          tbody.appendChild(tr);
        });

        visibleGroups.push({ ...group, shiftsArray: shiftsToRender });
      });

      if (filterActive && tbody.children.length === 0) {
        tbody.innerHTML = `<tr><td colspan="${colCount}" style="text-align: center; padding: 1.25rem; color: #666;">No rows match the current filters.</td></tr>`;
      }

      if (!filterActive) {
        renderSummary(tab, groups);
      } else {
        renderSummary(tab, visibleGroups);
      }
    }

    // Track inline time change
    function onInlineTimeChange(tab, groupIdx, shiftIdx, field, value) {
      const group = entriesData[tab][groupIdx];
      if (!group) return;
      const shift = group.shiftsArray?.[shiftIdx];
      if (!shift) return;

      // Update all modalities in this shift with new time
      Object.keys(shift.modalities).forEach(modKey => {
        const modData = shift.modalities[modKey];
        const key = `${modKey}-${modData.row_index}`;
        if (!pendingChanges[tab][key]) {
          pendingChanges[tab][key] = { modality: modKey, row_index: modData.row_index, updates: {} };
        }
        pendingChanges[tab][key].updates[field === 'start' ? 'start_time' : 'end_time'] = value;
      });
    }

    // Track inline modifier change for the whole shift (one modifier)
    function onInlineShiftModifierChange(tab, groupIdx, shiftIdx, value) {
      const group = entriesData[tab][groupIdx];
      if (!group) return;
      const shift = group.shiftsArray?.[shiftIdx];
      if (!shift) return;

      const parsed = parseFloat(value);
      shift.modifier = parsed;

      Object.entries(shift.modalities).forEach(([modKey, modData]) => {
        if (modData.row_index === undefined || modData.row_index < 0) return;
        const key = `${modKey}-${modData.row_index}`;
        if (!pendingChanges[tab][key]) {
          pendingChanges[tab][key] = { modality: modKey, row_index: modData.row_index, updates: {} };
        }
        pendingChanges[tab][key].updates['Modifier'] = parsed;
      });
    }

    // Delete all entries for a worker
    async function deleteWorkerEntries(tab, groupIdx) {
      const group = entriesData[tab][groupIdx];
      if (!group) return;

      const allEntries = group.allEntries || [];
      if (!confirm(`Delete all ${allEntries.length} entries for ${group.worker}?`)) return;

      const endpoint = tab === 'today' ? '/api/live-schedule/delete-worker' : '/api/prep-next-day/delete-worker';

      try {
        // Delete all entries in reverse order (to avoid index shifting issues)
        // Sort by row_index descending to delete from end first
        const sortedEntries = [...allEntries].sort((a, b) => b.row_index - a.row_index);
        for (const entry of sortedEntries) {
          await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ modality: entry.modality, row_index: entry.row_index })
          });
        }
        showMessage('success', `Deleted all entries for ${group.worker}`);
        await loadData();
      } catch (error) {
        showMessage('error', error.message);
      }
    }

    // Delete single entry
    async function deleteEntry(tab, groupIdx, entryIdx) {
      const group = entriesData[tab][groupIdx];
      if (!group) return;
      const entry = group.entries[entryIdx];
      if (!entry) return;

      if (!confirm(`Delete entry for ${entry.worker} (${entry.modality.toUpperCase()} ${entry.start_time}-${entry.end_time})?`)) return;

      const endpoint = tab === 'today' ? '/api/live-schedule/delete-worker' : '/api/prep-next-day/delete-worker';

      try {
        await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ modality: entry.modality, row_index: entry.row_index })
        });
        showMessage('success', `Deleted entry for ${entry.worker}`);
        await loadData();
      } catch (error) {
        showMessage('error', error.message);
      }
    }

    // Open Edit modal for a worker - edit skills per modality
    function openEditModal(tab, groupIdx) {
      const group = entriesData[tab][groupIdx];
      if (!group) return;

      currentEditEntry = { tab, groupIdx };
      renderEditModalContent();
      document.getElementById('edit-modal').classList.add('show');
    }

    function renderEditModalContent() {
      const { tab, groupIdx } = currentEditEntry;
      const group = entriesData[tab][groupIdx];
      if (!group) return;

      let html = '';

      // XSS-safe rendering
      const escapedWorker = escapeHtml(group.worker);
      const shifts = group.shiftsArray || [];
      const numShifts = shifts.length;
      const duplicateBadge = numShifts > 1 ? `<span class="duplicate-badge">${numShifts}x</span>` : '';
      const borderColor = tab === 'today' ? (UI_COLORS.today_tab || '#28a745') : (UI_COLORS.tomorrow_tab || '#ffc107');

      // Header with worker name (similar to Add Worker modal)
      html += `<div style="margin-bottom: 1rem; padding: 0.75rem; background: #f8f9fa; border-radius: 8px;">
        <div class="form-group" style="margin-bottom: 0;">
          <label style="font-weight: 600; display: block; margin-bottom: 0.3rem;">Worker</label>
          <div style="font-size: 1rem; padding: 0.5rem; background: #e9ecef; border-radius: 4px;">
            <strong>${escapedWorker}</strong> ${duplicateBadge}
          </div>
        </div>
      </div>`;

      // Section title for existing shifts
      html += `<div style="margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
        <label style="font-weight: 600; font-size: 1rem;">Existing Shifts/Tasks</label>
      </div>`;

      // Render each existing shift section (like Add Worker task cards)
      shifts.forEach((shift, shiftIdx) => {
        // Get the first assigned modality for this shift
        const assignedMods = Object.entries(shift.modalities)
          .filter(([_, data]) => data.row_index !== undefined && data.row_index >= 0)
          .map(([mod]) => mod);
        const primaryMod = assignedMods[0] || MODALITIES[0]?.toLowerCase() || 'ct';
        const modData = shift.modalities[primaryMod] || { skills: {}, row_index: -1, modifier: shift.modifier || 1.0 };

        // Detect if this is a gap entry (all skills are -1)
        const isGapEntry = SKILLS.every(skill => {
          const val = modData.skills[skill];
          return val === -1 || val === '-1';
        });

        html += `<div style="margin-bottom: 1rem; padding: 0.75rem; border: 2px solid ${borderColor}; border-radius: 8px; background: #fafafa;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
            <span style="font-weight: 600; color: #333;">Shift ${shiftIdx + 1}${isGapEntry ? ' <span style="background:#f8d7da;color:#721c24;padding:0.1rem 0.3rem;border-radius:3px;font-size:0.7rem;">GAP</span>' : ''}</span>
            <button class="btn btn-small" style="background: #dc3545; color: white;" onclick="deleteShiftFromModal(${shiftIdx})">✕ Delete</button>
          </div>

          <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: flex-end; margin-bottom: 0.5rem;">
            <div style="flex: 1; min-width: 180px;">
              <label style="font-size: 0.75rem; color: #666; display: block;">Shift / Task</label>
              <select id="edit-shift-${shiftIdx}-task" onchange="onEditShiftTaskChange(${shiftIdx}, this.value)" style="width: 100%; padding: 0.4rem; font-size: 0.85rem;">
                ${renderTaskOptionsWithGroups(shift.task || '', true)}
              </select>
            </div>

            <div style="min-width: 80px;">
              <label style="font-size: 0.75rem; color: #666; display: block;">Modality</label>
              <select id="edit-shift-${shiftIdx}-modality" style="width: 100%; padding: 0.4rem; font-size: 0.85rem;">`;
        MODALITIES.forEach(mod => {
          const modLower = mod.toLowerCase();
          const isSelected = assignedMods.includes(modLower);
          html += `<option value="${mod}" ${isSelected ? 'selected' : ''}>${mod.toUpperCase()}</option>`;
        });
        html += `</select>
            </div>

            <div style="min-width: 90px;">
              <label style="font-size: 0.75rem; color: #666; display: block;">Start</label>
              <input type="time" id="edit-shift-${shiftIdx}-start" value="${shift.start_time || '07:00'}" style="padding: 0.4rem; font-size: 0.85rem;">
            </div>

            <div style="min-width: 90px;">
              <label style="font-size: 0.75rem; color: #666; display: block;">End</label>
              <input type="time" id="edit-shift-${shiftIdx}-end" value="${shift.end_time || '15:00'}" style="padding: 0.4rem; font-size: 0.85rem;">
            </div>

            <div style="min-width: 70px;">
              <label style="font-size: 0.75rem; color: #666; display: block;">Modifier</label>
              <select id="edit-shift-${shiftIdx}-modifier" style="padding: 0.4rem; font-size: 0.85rem;">
                <option value="0.5" ${shift.modifier === 0.5 ? 'selected' : ''}>0.5x</option>
                <option value="0.75" ${shift.modifier === 0.75 ? 'selected' : ''}>0.75x</option>
                <option value="1.0" ${!shift.modifier || shift.modifier === 1.0 ? 'selected' : ''}>1.0x</option>
                <option value="1.25" ${shift.modifier === 1.25 ? 'selected' : ''}>1.25x</option>
                <option value="1.5" ${shift.modifier === 1.5 ? 'selected' : ''}>1.5x</option>
              </select>
            </div>
          </div>

          <div>
            <label style="font-size: 0.75rem; color: #666; display: block; margin-bottom: 0.25rem;">Skills:</label>
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">`;

        // Store row indices for all modalities in this shift
        Object.entries(shift.modalities).forEach(([modKey, data]) => {
          html += `<input type="hidden" id="edit-shift-${shiftIdx}-${modKey}-rowindex" value="${data.row_index !== undefined ? data.row_index : -1}">`;
        });

        // Skills displayed inline like Add Worker modal (using primary modality's values)
        SKILLS.forEach(skill => {
          const skillSettings = SKILL_SETTINGS[skill] || {};
          const btnColor = skillSettings.button_color || '#6c757d';
          const rawVal = modData.skills[skill] !== undefined ? modData.skills[skill] : 0;
          const val = normalizeSkillValueJS(rawVal);
          html += `<div style="display: flex; align-items: center; gap: 0.2rem;">
              <select id="edit-shift-${shiftIdx}-skill-${skill}" style="padding: 0.2rem; font-size: 0.75rem; width: 42px;">
                <option value="-1" ${val === -1 ? 'selected' : ''}>-1</option>
                <option value="0" ${val === 0 ? 'selected' : ''}>0</option>
                <option value="1" ${val === 1 ? 'selected' : ''}>1</option>
                <option value="w" ${isWeightedSkill(val) ? 'selected' : ''}>w</option>
              </select>
              <span style="font-size: 0.7rem; background: ${btnColor}; color: ${skillSettings.text_color || '#fff'}; padding: 0.1rem 0.3rem; border-radius: 3px;">${escapeHtml(skill)}</span>
            </div>`;
        });

        html += `</div>
          </div>
        </div>`;
      });

      // Add New Shift/Gap section (same styling as Add Worker modal)
      html += `<div style="margin-bottom: 1rem; padding: 0.75rem; background: #d4edda; border: 2px solid #28a745; border-radius: 8px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
          <label style="font-weight: 600; color: #155724;">+ Add New Shift / Gap</label>
          <button class="btn btn-small btn-success" type="button" onclick="addShiftFromModal()">Add</button>
        </div>
        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: flex-end; margin-bottom: 0.5rem;">
          <div style="flex: 1; min-width: 180px;">
            <label style="font-size: 0.75rem; color: #666; display: block;">Shift / Task</label>
            <select id="modal-add-task" onchange="onModalTaskChange()" style="width: 100%; padding: 0.4rem; font-size: 0.85rem;">
              ${renderTaskOptionsWithGroups('', true)}
            </select>
          </div>
          <div style="min-width: 80px;">
            <label style="font-size: 0.75rem; color: #666; display: block;">Modality</label>
            <select id="modal-add-modality" style="width: 100%; padding: 0.4rem; font-size: 0.85rem;">`;
      MODALITIES.forEach(mod => {
        html += `<option value="${mod}">${mod.toUpperCase()}</option>`;
      });
      html += `</select>
          </div>
          <div style="min-width: 90px;">
            <label style="font-size: 0.75rem; color: #666; display: block;">Start</label>
            <input type="time" id="modal-add-start" value="07:00" style="padding: 0.4rem; font-size: 0.85rem;">
          </div>
          <div style="min-width: 90px;">
            <label style="font-size: 0.75rem; color: #666; display: block;">End</label>
            <input type="time" id="modal-add-end" value="15:00" style="padding: 0.4rem; font-size: 0.85rem;">
          </div>
          <div style="min-width: 70px;">
            <label style="font-size: 0.75rem; color: #666; display: block;">Modifier</label>
            <select id="modal-add-modifier" style="padding: 0.4rem; font-size: 0.85rem;">
              <option value="0.5">0.5x</option>
              <option value="0.75">0.75x</option>
              <option value="1.0" selected>1.0x</option>
              <option value="1.25">1.25x</option>
              <option value="1.5">1.5x</option>
            </select>
          </div>
        </div>
        <div id="modal-add-skills">
          <label style="font-size: 0.75rem; color: #666; display: block; margin-bottom: 0.25rem;">Skills:</label>
          <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">`;
      SKILLS.forEach(skill => {
        const skillSettings = SKILL_SETTINGS[skill] || {};
        const btnColor = skillSettings.button_color || '#6c757d';
        html += `<div style="display: flex; align-items: center; gap: 0.2rem;">
            <select id="modal-add-skill-${skill}" style="padding: 0.2rem; font-size: 0.75rem; width: 42px;">
              <option value="-1">-1</option>
              <option value="0" selected>0</option>
              <option value="1">1</option>
              <option value="w">w</option>
            </select>
            <span style="font-size: 0.7rem; background: ${btnColor}; color: ${skillSettings.text_color || '#fff'}; padding: 0.1rem 0.3rem; border-radius: 3px;">${escapeHtml(skill)}</span>
          </div>`;
      });
      html += `</div>
        </div>
      </div>`;

      document.getElementById('modal-title').textContent = `Edit Worker - ${group.worker}`;
      document.getElementById('modal-content').innerHTML = html;

      // Prefill the add-shift section with config + roster defaults for faster entry
      initializeModalAddForm();
    }

    // Handle task change in existing shift (edit modal)
    function onEditShiftTaskChange(shiftIdx, taskName) {
      const taskConfig = TASK_ROLES.find(t => t.name === taskName);
      if (!taskConfig) return;

      const isGap = taskConfig.type === 'gap' || taskConfig.exclusion;

      if (isGap) {
        // Gap selected - set all skills to -1 and use schedule times
        const schedule = taskConfig.schedule || {};
        const days = ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
        const today = days[new Date().getDay()];
        if (schedule[today]) {
          const [startTime, endTime] = schedule[today].split('-');
          const startEl = document.getElementById(`edit-shift-${shiftIdx}-start`);
          const endEl = document.getElementById(`edit-shift-${shiftIdx}-end`);
          if (startEl) startEl.value = startTime;
          if (endEl) endEl.value = endTime;
        }
        const modifierEl = document.getElementById(`edit-shift-${shiftIdx}-modifier`);
        if (modifierEl) modifierEl.value = '1.0';

        // Set ALL skills to -1 for gaps
        SKILLS.forEach(skill => {
          const skillSelect = document.getElementById(`edit-shift-${shiftIdx}-skill-${skill}`);
          if (skillSelect) skillSelect.value = '-1';
        });
      } else {
        // Regular shift selected
        const shiftConfig = SHIFT_TIMES[taskConfig.shift || 'Fruehdienst'] || {};
        const shiftDefault = shiftConfig.default || '07:00-15:00';
        const [startTime, endTime] = shiftDefault.split('-');
        const startEl = document.getElementById(`edit-shift-${shiftIdx}-start`);
        const endEl = document.getElementById(`edit-shift-${shiftIdx}-end`);
        if (startEl) startEl.value = startTime;
        if (endEl) endEl.value = endTime;

        const modifierEl = document.getElementById(`edit-shift-${shiftIdx}-modifier`);
        if (modifierEl && taskConfig.modifier) modifierEl.value = taskConfig.modifier.toString();

        // Set modality if available
        const modalitySelect = document.getElementById(`edit-shift-${shiftIdx}-modality`);
        if (modalitySelect && taskConfig.modalities && taskConfig.modalities[0]) {
          modalitySelect.value = taskConfig.modalities[0];
        }

        // Set skills from task config
        const taskSkills = taskConfig.base_skills || {};
        SKILLS.forEach(skill => {
          const skillSelect = document.getElementById(`edit-shift-${shiftIdx}-skill-${skill}`);
          if (skillSelect) {
            const val = taskSkills[skill] !== undefined ? taskSkills[skill] : 0;
            skillSelect.value = val.toString();
          }
        });

        // Apply worker roster exclusions (-1)
        const { tab, groupIdx } = currentEditEntry || {};
        const group = entriesData[tab]?.[groupIdx];
        if (group) {
          const preset = WORKER_SKILLS[group.worker];
          if (preset) {
            const rosterSkills = preset.skills || preset;
            SKILLS.forEach(skill => {
              const taskVal = taskSkills[skill];
              if (taskVal === undefined || taskVal <= 0) {
                const skillSelect = document.getElementById(`edit-shift-${shiftIdx}-skill-${skill}`);
                if (skillSelect && rosterSkills && rosterSkills[skill] === -1) {
                  skillSelect.value = '-1';
                }
              }
            });
          }
        }
      }
    }

    // Delete shift from edit modal
    async function deleteShiftFromModal(shiftIdx) {
      const { tab, groupIdx } = currentEditEntry || {};
      const group = entriesData[tab]?.[groupIdx];
      if (!group) return;

      const shifts = group.shiftsArray || [];
      const shift = shifts[shiftIdx];
      if (!shift) return;

      if (!confirm(`Delete this shift (${shift.start_time}-${shift.end_time})?`)) return;

      const endpoint = tab === 'today' ? '/api/live-schedule/delete-worker' : '/api/prep-next-day/delete-worker';

      try {
        // Delete all modality entries for this shift
        for (const [modKey, modData] of Object.entries(shift.modalities)) {
          if (modData.row_index !== undefined && modData.row_index >= 0) {
            await fetch(endpoint, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ modality: modKey, row_index: modData.row_index })
            });
          }
        }
        showMessage('success', 'Shift deleted');
        closeModal();
        await loadData();
      } catch (error) {
        showMessage('error', error.message);
      }
    }

    // Handle task change in modal add shift section
    function onModalTaskChange() {
      const taskSelect = document.getElementById('modal-add-task');
      const modalitySelect = document.getElementById('modal-add-modality');
      const skillsContainer = document.getElementById('modal-add-skills');

      const option = taskSelect.options[taskSelect.selectedIndex];
      if (!option || !option.value) {
        skillsContainer.style.display = 'none';
        return;
      }

      const isGap = option.dataset.type === 'gap' || option.dataset.exclusion === 'true';

      if (isGap) {
        // Gap selected - set all skills to -1 and use schedule times
        skillsContainer.style.display = 'block';

        // Get schedule-based times for today
        const schedule = JSON.parse(option.dataset.schedule || '{}');
        const days = ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
        const today = days[new Date().getDay()];
        if (schedule[today]) {
          const [startTime, endTime] = schedule[today].split('-');
          document.getElementById('modal-add-start').value = startTime;
          document.getElementById('modal-add-end').value = endTime;
        } else {
          // Default times if no schedule for today
          document.getElementById('modal-add-start').value = '12:00';
          document.getElementById('modal-add-end').value = '13:00';
        }

        // Set modifier to 1.0 for gaps
        document.getElementById('modal-add-modifier').value = '1.0';

        // Set ALL skills to -1 for gaps
        SKILLS.forEach(skill => {
          const skillSelect = document.getElementById(`modal-add-skill-${skill}`);
          if (skillSelect) skillSelect.value = '-1';
        });
        return;
      }

      // Regular shift selected
      skillsContainer.style.display = 'block';

      // Set modality from task config
      const modalities = JSON.parse(option.dataset.modalities || '[]');
      if (modalities.length > 0) {
        modalitySelect.value = modalities[0];
      }

      // Set times from shift config
      const shiftName = option.dataset.shift || 'Fruehdienst';
      const shiftConfig = SHIFT_TIMES[shiftName] || {};
      const shiftDefault = shiftConfig.default || '07:00-15:00';
      const [startTime, endTime] = shiftDefault.split('-');
      document.getElementById('modal-add-start').value = startTime;
      document.getElementById('modal-add-end').value = endTime;

      // Set modifier from task config
      const modifier = option.dataset.modifier || '1.0';
      document.getElementById('modal-add-modifier').value = modifier;

      // Set skills from task config
      const taskSkills = JSON.parse(option.dataset.skills || '{}');
      SKILLS.forEach(skill => {
        const skillSelect = document.getElementById(`modal-add-skill-${skill}`);
        if (skillSelect) {
          const val = taskSkills[skill] !== undefined ? taskSkills[skill] : 0;
          skillSelect.value = val.toString();
        }
      });

      // Merge with worker roster skills (apply -1 exclusions)
      const { tab, groupIdx } = currentEditEntry || {};
      const group = entriesData[tab]?.[groupIdx];
      if (group) {
        const preset = WORKER_SKILLS[group.worker];
        if (preset) {
          const rosterSkills = preset.skills || preset;
          SKILLS.forEach(skill => {
            const taskVal = taskSkills[skill];
            if (taskVal === undefined || taskVal <= 0) {
              const skillSelect = document.getElementById(`modal-add-skill-${skill}`);
              if (skillSelect && rosterSkills && rosterSkills[skill] === -1) {
                skillSelect.value = '-1';
              }
            }
          });
        }
      }
    }

    // Initialize modal add-shift form with sensible defaults from config and roster
    function initializeModalAddForm() {
      const taskSelect = document.getElementById('modal-add-task');
      const skillsContainer = document.getElementById('modal-add-skills');

      if (!taskSelect || !skillsContainer) return;

      // Auto-select first task if none chosen to trigger config preload
      if (!taskSelect.value && taskSelect.options.length > 1) {
        taskSelect.selectedIndex = 1;
      }

      if (taskSelect.value) {
        onModalTaskChange();
        skillsContainer.style.display = 'block';
      } else {
        // If no task available, still expose skills with roster defaults
        skillsContainer.style.display = 'block';
        const { tab, groupIdx } = currentEditEntry || {};
        const group = entriesData[tab]?.[groupIdx];
        const preset = group ? WORKER_SKILLS[group.worker] : null;
        const rosterSkills = preset ? (preset.skills || preset) : {};

        SKILLS.forEach(skill => {
          const el = document.getElementById(`modal-add-skill-${skill}`);
          if (el) {
            const val = rosterSkills[skill] !== undefined ? rosterSkills[skill] : 0;
            el.value = val.toString();
          }
        });
      }
    }

    // Add shift from modal
    async function addShiftFromModal() {
      const { tab, groupIdx } = currentEditEntry || {};
      const group = entriesData[tab]?.[groupIdx];
      if (!group) return;

      const taskSelect = document.getElementById('modal-add-task');
      const taskName = taskSelect.value;
      const modality = document.getElementById('modal-add-modality').value;
      const startTime = document.getElementById('modal-add-start').value;
      const endTime = document.getElementById('modal-add-end').value;
      const modifier = parseFloat(document.getElementById('modal-add-modifier').value) || 1.0;

      // Gather skills
      const skills = {};
      SKILLS.forEach(skill => {
        const el = document.getElementById(`modal-add-skill-${skill}`);
        skills[skill] = normalizeSkillValueJS(el ? el.value : 0);
      });

      const endpoint = tab === 'today' ? '/api/live-schedule/add-worker' : '/api/prep-next-day/add-worker';

      try {
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            modality,
            worker_data: {
              PPL: group.worker,
              start_time: startTime,
              end_time: endTime,
              Modifier: modifier,
              tasks: taskName,
              ...skills
            }
          })
        });

        if (response.ok) {
          showMessage('success', `Added new shift for ${group.worker}`);
          closeModal();
          await loadData();
        } else {
          const errData = await response.json().catch(() => ({}));
          showMessage('error', errData.error || 'Failed to add shift');
        }
      } catch (error) {
        showMessage('error', error.message);
      }
    }

    // Helper functions for modality colors (from config)
    function getModalityColor(modKey) {
      const settings = MODALITY_SETTINGS[modKey];
      return settings?.nav_color || '#6c757d';
    }

    function getModalityBgColor(modKey) {
      const settings = MODALITY_SETTINGS[modKey];
      return settings?.background_color || '#f8f9fa';
    }

    function onEditGapTypeChange() {
      const select = document.getElementById('edit-gap-type');
      const startInput = document.getElementById('edit-gap-start');
      const endInput = document.getElementById('edit-gap-end');

      if (!select.value) {
        startInput.disabled = true;
        endInput.disabled = true;
        return;
      }

      startInput.disabled = false;
      endInput.disabled = false;

      const option = select.options[select.selectedIndex];
      if (option.value !== 'custom' && option.dataset.schedule) {
        const schedule = JSON.parse(option.dataset.schedule);
        const days = ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
        const today = days[new Date().getDay()];
        if (schedule[today]) {
          const [start, end] = schedule[today].split('-');
          startInput.value = start;
          endInput.value = end;
        }
      }
    }

    function applySkillValues(skillMap = {}) {
      SKILLS.forEach(skill => {
        if (skillMap[skill] !== undefined) {
          const el = document.getElementById(`edit-skill-${skill}`);
          if (el) {
            el.value = skillMap[skill];
          }
        }
      });
    }

    function applyTaskSkillPreset() {
      const taskSelect = document.getElementById('edit-task');
      if (!taskSelect) return;
      const option = taskSelect.options[taskSelect.selectedIndex];
      if (!option || !option.dataset.skills) return;

      try {
        const skills = JSON.parse(option.dataset.skills) || {};
        applySkillValues(skills);

        // Also apply modifier from task config
        const taskName = option.value;
        const taskConfig = TASK_ROLES.find(t => t.name === taskName);
        if (taskConfig && taskConfig.modifier !== undefined) {
          const modifierSelect = document.getElementById('edit-modifier');
          if (modifierSelect) {
            modifierSelect.value = taskConfig.modifier.toString();
          }
        }
      } catch (err) {
        console.error('Failed to apply task skill preset', err);
      }
    }

    function applyWorkerSkillPreset(workerName) {
      // Legacy function - kept for compatibility
      const preset = WORKER_SKILLS[workerName];
      if (!preset) {
        showMessage('error', `No skill preset found for ${workerName}`);
        return;
      }

      const skills = preset.skills || preset;

      const sanitized = {};
      SKILLS.forEach(skill => {
        if (skills && skills[skill] !== undefined) {
          // Limit roster presets to 0/-1; positive values are reserved for manual/CSV edits
          const val = skills[skill];
          sanitized[skill] = val > 0 ? 0 : val;
        }
      });

      applySkillValues(sanitized);
    }

    // Apply worker skill preset for a specific modality (legacy - kept for compatibility)
    function applyWorkerSkillPresetForModality(workerName, modKey) {
      const preset = WORKER_SKILLS[workerName];
      if (!preset) {
        showMessage('error', `No skill preset found for ${workerName}`);
        return;
      }

      // Check for modality-specific override first, then default
      const modalitySkills = preset[modKey] ? preset[modKey] : null;
      const skills = modalitySkills || preset.skills || preset;

      SKILLS.forEach(skill => {
        const el = document.getElementById(`edit-${modKey}-skill-${skill}`);
        if (el && skills && skills[skill] !== undefined) {
          // Limit roster presets to 0/-1; positive values are reserved for manual/CSV edits
          const val = skills[skill];
          el.value = (val > 0 ? 0 : val).toString();
        }
      });
    }

    // Apply worker skill preset for a specific modality in a specific shift
    function applyWorkerSkillPresetForShiftModality(workerName, shiftIdx, modKey) {
      const preset = WORKER_SKILLS[workerName];
      if (!preset) {
        showMessage('error', `No skill preset found for ${workerName}`);
        return;
      }

      // Check for modality-specific override first, then default
      const modalitySkills = preset[modKey] ? preset[modKey] : null;
      const skills = modalitySkills || preset.skills || preset;

      SKILLS.forEach(skill => {
        const el = document.getElementById(`edit-shift-${shiftIdx}-${modKey}-skill-${skill}`);
        if (el && skills && skills[skill] !== undefined) {
          // Limit roster presets to 0/-1; positive values are reserved for manual/CSV edits
          const val = skills[skill];
          el.value = (val > 0 ? 0 : val).toString();
        }
      });
    }

    // Apply preset from config to all modalities in a shift
    function applyPresetToShift(shiftIdx, taskName) {
      if (!taskName) return;

      const task = TASK_ROLES.find(t => t.name === taskName);
      if (!task) {
        showMessage('error', `Preset not found: ${taskName}`);
        return;
      }

      const taskSkills = task.base_skills || {};
      const { tab, groupIdx } = currentEditEntry || {};
      const group = entriesData[tab]?.[groupIdx];
      if (!group) return;

      const shift = group.shiftsArray?.[shiftIdx];
      if (!shift) return;

      // Apply skills to all modalities in this shift
      Object.keys(shift.modalities).forEach(modKey => {
        SKILLS.forEach(skill => {
          const el = document.getElementById(`edit-shift-${shiftIdx}-${modKey}-skill-${skill}`);
          if (el) {
            const val = taskSkills[skill] !== undefined ? taskSkills[skill] : 0;
            el.value = val.toString();
          }
        });
      });

      // Apply modifier if task has one (for weighted skills)
      if (task.modifier !== undefined) {
        const modifierEl = document.getElementById(`edit-shift-${shiftIdx}-modifier`);
        if (modifierEl) {
          modifierEl.value = task.modifier.toString();
        }
      }

      // Update shift times from task config
      const shiftName = task.shift || 'Fruehdienst';
      const shiftConfig = SHIFT_TIMES[shiftName] || {};
      const shiftDefault = shiftConfig.default || '07:00-15:00';
      const [startTime, endTime] = shiftDefault.split('-');

      const startEl = document.getElementById(`edit-shift-${shiftIdx}-start`);
      const endEl = document.getElementById(`edit-shift-${shiftIdx}-end`);
      if (startEl) startEl.value = startTime;
      if (endEl) endEl.value = endTime;
    }

    // Apply worker roster skills to all modalities in a shift
    function applyWorkerRosterToShift(shiftIdx) {
      const { tab, groupIdx } = currentEditEntry || {};
      const group = entriesData[tab]?.[groupIdx];
      if (!group) return;

      const preset = WORKER_SKILLS[group.worker];
      if (!preset) {
        showMessage('error', `No skill preset found for ${group.worker}`);
        return;
      }

      const shift = group.shiftsArray?.[shiftIdx];
      if (!shift) return;

      // Apply skills to all modalities in this shift
      Object.keys(shift.modalities).forEach(modKey => {
        // Check for modality-specific override first, then default
        const modalitySkills = preset[modKey] || null;
        const skills = modalitySkills || preset.skills || preset;

        SKILLS.forEach(skill => {
          const el = document.getElementById(`edit-shift-${shiftIdx}-${modKey}-skill-${skill}`);
          if (el && skills && skills[skill] !== undefined) {
            // Limit roster presets to 0/-1; positive values are reserved for manual/CSV edits
            const val = skills[skill];
            el.value = (val > 0 ? 0 : val).toString();
          }
        });
      });
    }

    async function saveModalChanges() {
      if (!currentEditEntry) return;

      const { tab, groupIdx } = currentEditEntry;
      const group = entriesData[tab][groupIdx];
      if (!group) return;

      const updateEndpoint = tab === 'today' ? '/api/live-schedule/update-row' : '/api/prep-next-day/update-row';
      const shifts = group.shiftsArray || [];

      try {
        // Update all existing shifts with new simplified structure
        for (let shiftIdx = 0; shiftIdx < shifts.length; shiftIdx++) {
          const shift = shifts[shiftIdx];

          // Get updated values from the simplified form
          const shiftTaskEl = document.getElementById(`edit-shift-${shiftIdx}-task`);
          const shiftModalityEl = document.getElementById(`edit-shift-${shiftIdx}-modality`);
          const shiftStartEl = document.getElementById(`edit-shift-${shiftIdx}-start`);
          const shiftEndEl = document.getElementById(`edit-shift-${shiftIdx}-end`);
          const shiftModifierEl = document.getElementById(`edit-shift-${shiftIdx}-modifier`);

          const shiftTask = shiftTaskEl ? shiftTaskEl.value : shift.task;
          const selectedModality = shiftModalityEl ? shiftModalityEl.value.toLowerCase() : null;
          const shiftStart = shiftStartEl ? shiftStartEl.value : shift.start_time;
          const shiftEnd = shiftEndEl ? shiftEndEl.value : shift.end_time;
          const shiftModifier = shiftModifierEl ? parseFloat(shiftModifierEl.value) || 1.0 : shift.modifier || 1.0;

          // Get skills from the simplified skill inputs
          const skillUpdates = {};
          SKILLS.forEach(skill => {
            const el = document.getElementById(`edit-shift-${shiftIdx}-skill-${skill}`);
            if (el) {
              skillUpdates[skill] = normalizeSkillValueJS(el.value);
            }
          });

          // Update all modalities that have row_index in this shift
          for (const [modKey, modData] of Object.entries(shift.modalities)) {
            const rowIndexEl = document.getElementById(`edit-shift-${shiftIdx}-${modKey}-rowindex`);
            const rowIndex = rowIndexEl ? parseInt(rowIndexEl.value) : modData.row_index;

            if (rowIndex >= 0) {
              const updates = {
                start_time: shiftStart,
                end_time: shiftEnd,
                Modifier: shiftModifier,
                tasks: shiftTask,
                ...skillUpdates
              };

              const response = await fetch(updateEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  modality: modKey,
                  row_index: rowIndex,
                  updates: updates
                })
              });

              if (!response.ok) {
                const result = await response.json();
                throw new Error(result.error || `Failed to update ${modKey.toUpperCase()} entry`);
              }
            }
          }
        }

        closeModal();
        showMessage('success', 'Worker entries updated');
        await loadData();
      } catch (error) {
        showMessage('error', error.message);
      }
    }

    function closeModal() {
      document.getElementById('edit-modal').classList.remove('show');
      currentEditEntry = null;
    }

    // =============================================
    // ADD WORKER MODAL FUNCTIONS
    // =============================================

    function openAddWorkerModal(tab) {
      addWorkerModalState.tab = tab;
      addWorkerModalState.tasks = [];
      // Start with one empty task
      addTaskToAddWorkerModal();
      renderAddWorkerModalContent();
      document.getElementById('add-worker-modal').classList.add('show');
      document.getElementById('add-worker-modal-title').textContent = tab === 'today' ? 'Add Worker (Today)' : 'Add Worker (Tomorrow)';
    }

    function closeAddWorkerModal() {
      document.getElementById('add-worker-modal').classList.remove('show');
      addWorkerModalState.tab = null;
      addWorkerModalState.tasks = [];
    }

    function addTaskToAddWorkerModal() {
      // Find default task to prefill
      const defaultTask = TASK_ROLES.find(t => !t.exclusion) || {};
      const defaultMod = (defaultTask.modalities && defaultTask.modalities[0]) || MODALITIES[0] || 'ct';
      const shiftConfig = SHIFT_TIMES[defaultTask.shift || 'Fruehdienst'] || {};
      const [startTime, endTime] = (shiftConfig.default || '07:00-15:00').split('-');

      // Default skills from task
      const defaultSkills = {};
      SKILLS.forEach(skill => {
        defaultSkills[skill] = defaultTask.base_skills ? (defaultTask.base_skills[skill] || 0) : 0;
      });

      addWorkerModalState.tasks.push({
        task: defaultTask.name || '',
        modality: defaultMod,
        start_time: startTime,
        end_time: endTime,
        modifier: defaultTask.modifier || 1.0,
        skills: defaultSkills
      });
    }

    function removeTaskFromAddWorkerModal(idx) {
      if (addWorkerModalState.tasks.length <= 1) {
        showMessage('error', 'At least one task is required');
        return;
      }
      addWorkerModalState.tasks.splice(idx, 1);
      renderAddWorkerModalContent();
    }

    function updateAddWorkerTask(idx, field, value) {
      if (!addWorkerModalState.tasks[idx]) return;
      addWorkerModalState.tasks[idx][field] = value;

      // If task changed, update modality, times, modifier, and skills
      if (field === 'task') {
        const taskConfig = TASK_ROLES.find(t => t.name === value);
        if (taskConfig) {
          const task = addWorkerModalState.tasks[idx];
          const isGap = taskConfig.type === 'gap' || taskConfig.exclusion;

          if (isGap) {
            // Gap selected - set all skills to -1 and use schedule times
            task.modifier = 1.0;

            // Get schedule-based times for today
            const schedule = taskConfig.schedule || {};
            const days = ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
            const today = days[new Date().getDay()];
            if (schedule[today]) {
              const [startTime, endTime] = schedule[today].split('-');
              task.start_time = startTime;
              task.end_time = endTime;
            } else {
              task.start_time = '12:00';
              task.end_time = '13:00';
            }

            // Set ALL skills to -1 for gaps
            SKILLS.forEach(skill => {
              task.skills[skill] = -1;
            });
          } else {
            // Regular shift selected
            task.modality = (taskConfig.modalities && taskConfig.modalities[0]) || task.modality;

            const shiftConfig = SHIFT_TIMES[taskConfig.shift || 'Fruehdienst'] || {};
            const [startTime, endTime] = (shiftConfig.default || '07:00-15:00').split('-');
            task.start_time = startTime;
            task.end_time = endTime;
            task.modifier = taskConfig.modifier || 1.0;

            // Update skills from task config
            SKILLS.forEach(skill => {
              task.skills[skill] = taskConfig.base_skills ? (taskConfig.base_skills[skill] || 0) : 0;
            });

            // Apply worker roster exclusions (-1) if worker is selected
            const workerInput = document.getElementById('add-worker-name-input');
            const workerName = workerInput ? workerInput.value.trim() : '';
            if (workerName && WORKER_SKILLS[workerName]) {
              const rosterSkills = WORKER_SKILLS[workerName].skills || WORKER_SKILLS[workerName];
              SKILLS.forEach(skill => {
                if (rosterSkills[skill] === -1 && (task.skills[skill] === 0 || task.skills[skill] === undefined)) {
                  task.skills[skill] = -1;
                }
              });
            }
          }

          renderAddWorkerModalContent();
        }
      }
    }

    function updateAddWorkerSkill(idx, skill, value) {
      if (!addWorkerModalState.tasks[idx]) return;
      const raw = (value || '').toString().trim();
      addWorkerModalState.tasks[idx].skills[skill] = raw === 'w' ? 'w' : (parseInt(raw, 10) || 0);
    }

    function onAddWorkerNameChange() {
      const workerInput = document.getElementById('add-worker-name-input');
      const workerName = workerInput ? workerInput.value.trim() : '';

      if (workerName && WORKER_SKILLS[workerName]) {
        const rosterSkills = WORKER_SKILLS[workerName].skills || WORKER_SKILLS[workerName];
        // Apply roster -1 values to any task with 0 value for that skill
        addWorkerModalState.tasks.forEach(task => {
          SKILLS.forEach(skill => {
            if (rosterSkills[skill] === -1 && (task.skills[skill] === 0 || task.skills[skill] === undefined)) {
              task.skills[skill] = -1;
            }
          });
        });
        renderAddWorkerModalContent();
      }
    }

    function renderAddWorkerModalContent() {
      const container = document.getElementById('add-worker-modal-content');
      const workerInput = document.getElementById('add-worker-name-input');
      const currentWorkerName = workerInput ? workerInput.value : '';

      let html = '';

      // Worker name input
      html += `<div style="margin-bottom: 1rem; padding: 0.75rem; background: #f8f9fa; border-radius: 8px;">
        <div class="form-group" style="margin-bottom: 0;">
          <label style="font-weight: 600; display: block; margin-bottom: 0.3rem;">Worker Name</label>
          <input type="text" id="add-worker-name-input" value="${escapeHtml(currentWorkerName)}" placeholder="e.g. Dr. Müller"
                 list="worker-list-datalist" autocomplete="off" onchange="onAddWorkerNameChange()" oninput="onAddWorkerNameChange()"
                 style="width: 100%; max-width: 300px; padding: 0.5rem; font-size: 1rem; border: 1px solid #ccc; border-radius: 4px;">
        </div>
      </div>`;

      // Tasks section
      html += `<div style="margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
        <label style="font-weight: 600; font-size: 1rem;">Tasks/Shifts</label>
        <button class="btn btn-success btn-small" onclick="addTaskToAddWorkerModal(); renderAddWorkerModalContent();">+ Add Task</button>
      </div>`;

      // Render each task
      addWorkerModalState.tasks.forEach((task, idx) => {
        const taskConfig = TASK_ROLES.find(t => t.name === task.task) || {};
        const availableModalities = taskConfig.modalities || MODALITIES;
        const borderColor = addWorkerModalState.tab === 'today' ? (UI_COLORS.today_tab || '#28a745') : (UI_COLORS.tomorrow_tab || '#ffc107');

        html += `<div style="margin-bottom: 1rem; padding: 0.75rem; border: 2px solid ${borderColor}; border-radius: 8px; background: #fafafa;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
            <span style="font-weight: 600; color: #333;">Task ${idx + 1}</span>
            <button class="btn btn-small" style="background: #dc3545; color: white;" onclick="removeTaskFromAddWorkerModal(${idx})">✕ Remove</button>
          </div>

          <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: flex-end; margin-bottom: 0.5rem;">
            <div style="flex: 1; min-width: 180px;">
              <label style="font-size: 0.75rem; color: #666; display: block;">Shift / Task</label>
              <select onchange="updateAddWorkerTask(${idx}, 'task', this.value)" style="width: 100%; padding: 0.4rem; font-size: 0.85rem;">
                ${renderTaskOptionsWithGroups(task.task, true)}
              </select>
            </div>

            <div style="min-width: 80px;">
              <label style="font-size: 0.75rem; color: #666; display: block;">Modality</label>
              <select onchange="updateAddWorkerTask(${idx}, 'modality', this.value)" style="width: 100%; padding: 0.4rem; font-size: 0.85rem;">`;
        availableModalities.forEach(mod => {
          html += `<option value="${mod}" ${task.modality === mod ? 'selected' : ''}>${mod.toUpperCase()}</option>`;
        });
        html += `</select>
            </div>

            <div style="min-width: 90px;">
              <label style="font-size: 0.75rem; color: #666; display: block;">Start</label>
              <input type="time" value="${task.start_time}" onchange="updateAddWorkerTask(${idx}, 'start_time', this.value)" style="padding: 0.4rem; font-size: 0.85rem;">
            </div>

            <div style="min-width: 90px;">
              <label style="font-size: 0.75rem; color: #666; display: block;">End</label>
              <input type="time" value="${task.end_time}" onchange="updateAddWorkerTask(${idx}, 'end_time', this.value)" style="padding: 0.4rem; font-size: 0.85rem;">
            </div>

            <div style="min-width: 70px;">
              <label style="font-size: 0.75rem; color: #666; display: block;">Modifier</label>
              <select onchange="updateAddWorkerTask(${idx}, 'modifier', parseFloat(this.value))" style="padding: 0.4rem; font-size: 0.85rem;">
                <option value="0.5" ${task.modifier === 0.5 ? 'selected' : ''}>0.5x</option>
                <option value="0.75" ${task.modifier === 0.75 ? 'selected' : ''}>0.75x</option>
                <option value="1.0" ${!task.modifier || task.modifier === 1.0 ? 'selected' : ''}>1.0x</option>
                <option value="1.25" ${task.modifier === 1.25 ? 'selected' : ''}>1.25x</option>
                <option value="1.5" ${task.modifier === 1.5 ? 'selected' : ''}>1.5x</option>
              </select>
            </div>
          </div>

          <div>
            <label style="font-size: 0.75rem; color: #666; display: block; margin-bottom: 0.25rem;">Skills:</label>
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">`;
        SKILLS.forEach(skill => {
          const skillSettings = SKILL_SETTINGS[skill] || {};
          const btnColor = skillSettings.button_color || '#6c757d';
          const skillVal = task.skills[skill] !== undefined ? task.skills[skill] : 0;
          html += `<div style="display: flex; align-items: center; gap: 0.2rem;">
              <select onchange="updateAddWorkerSkill(${idx}, '${skill}', this.value)" style="padding: 0.2rem; font-size: 0.75rem; width: 42px;">
                <option value="-1" ${skillVal === -1 ? 'selected' : ''}>-1</option>
                <option value="0" ${skillVal === 0 ? 'selected' : ''}>0</option>
                <option value="1" ${skillVal === 1 ? 'selected' : ''}>1</option>
                <option value="w" ${skillVal === 'w' ? 'selected' : ''}>w</option>
              </select>
              <span style="font-size: 0.7rem; background: ${btnColor}; color: ${skillSettings.text_color || '#fff'}; padding: 0.1rem 0.3rem; border-radius: 3px;">${escapeHtml(skill)}</span>
            </div>`;
        });
        html += `</div>
          </div>
        </div>`;
      });

      container.innerHTML = html;
    }

    async function saveAddWorkerModal() {
      const workerInput = document.getElementById('add-worker-name-input');
      const workerName = workerInput ? workerInput.value.trim() : '';

      if (!workerName) {
        showMessage('error', 'Please enter a worker name');
        return;
      }

      if (addWorkerModalState.tasks.length === 0) {
        showMessage('error', 'Please add at least one task');
        return;
      }

      const { tab, tasks } = addWorkerModalState;
      const endpoint = tab === 'today' ? '/api/live-schedule/add-worker' : '/api/prep-next-day/add-worker';

      try {
        // Add each task as a separate entry
        for (const task of tasks) {
          if (!task.task) {
            showMessage('error', 'Please select a task for all entries');
            return;
          }

          const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              modality: task.modality,
              worker_data: {
                PPL: workerName,
                start_time: task.start_time,
                end_time: task.end_time,
                Modifier: task.modifier,
                tasks: task.task,
                ...task.skills
              }
            })
          });

          if (!response.ok) {
            const errData = await response.json().catch(() => ({}));
            throw new Error(errData.error || 'Failed to add worker');
          }
        }

        closeAddWorkerModal();
        showMessage('success', `${workerName} added with ${tasks.length} task(s)`);
        await loadData();
      } catch (error) {
        showMessage('error', error.message);
      }
    }

    // =============================================
    // END ADD WORKER MODAL FUNCTIONS
    // =============================================


    // Load from CSV
    async function loadFromCSV(mode) {
      const statusId = mode === 'today' ? 'load-status-today' : 'load-status-tomorrow';
      const loadStatus = document.getElementById(statusId);
      loadStatus.textContent = 'Loading...';

      const endpoint = mode === 'today' ? '/load-today-from-master' : '/preload-from-master';

      try {
        const response = await fetch(endpoint, { method: 'POST' });
        const result = await response.json();

        if (response.ok) {
          loadStatus.textContent = result.message || 'Loaded!';
          loadStatus.style.color = '#28a745';
          await loadData();
        } else {
          loadStatus.textContent = result.error || 'Error';
          loadStatus.style.color = '#dc3545';
        }
      } catch (error) {
        loadStatus.textContent = 'Error: ' + error.message;
        loadStatus.style.color = '#dc3545';
      }

      setTimeout(() => { loadStatus.textContent = ''; }, 5000);
    }

    // Show message (XSS-safe)
    function showMessage(type, message) {
      const container = document.getElementById('message-container');
      const div = document.createElement('div');
      div.className = `message ${type}`;
      div.textContent = message;  // textContent is XSS-safe
      container.innerHTML = '';
      container.appendChild(div);
      setTimeout(() => { container.innerHTML = ''; }, 5000);
    }

    // Initialize edit mode UI and load current tab (lazy loading)
    applyEditModeUI('today');
    applyEditModeUI('tomorrow');
    loadTabData('today');
  </script>
</body>
</html>
