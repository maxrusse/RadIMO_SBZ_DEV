<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RadIMO Cortex | Change Today / Prep Tomorrow</title>
  <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #f0f0f0; padding: 1rem; max-width: 1800px; margin: 0 auto; }
    .header { background: #004892; color: white; padding: 1rem 2rem; border-radius: 8px; margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    .header h1 { margin: 0; font-size: 1.5rem; }
    .header-actions { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .header-actions a, .header-actions button { color: white; text-decoration: none; padding: 0.5rem 1rem; background: rgba(255,255,255,0.2); border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; }
    .header-actions a:hover, .header-actions button:hover { background: rgba(255,255,255,0.3); }
    .card { background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 1rem; }

    /* Tab Styles */
    .tab-container { display: flex; gap: 0; margin-bottom: 0; }
    .tab-btn { padding: 1rem 2rem; border: none; background: #e0e0e0; color: #666; font-size: 1rem; font-weight: 600; cursor: pointer; border-radius: 8px 8px 0 0; transition: all 0.2s; }
    .tab-btn:hover { background: #d0d0d0; }
    .tab-btn.active-today { background: #28a745; color: white; }
    .tab-btn.active-tomorrow { background: #ffc107; color: #333; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    /* Today Banner - Green */
    .today-banner { background: #d4edda; border: 2px solid #28a745; padding: 1rem; border-radius: 0 8px 8px 8px; margin-bottom: 1rem; }
    .today-banner h2 { color: #155724; margin-bottom: 0.5rem; font-size: 1.2rem; }
    .today-banner p { color: #155724; margin: 0.25rem 0; font-size: 0.9rem; }

    /* Tomorrow Banner - Yellow */
    .tomorrow-banner { background: #fff3cd; border: 2px solid #ffc107; padding: 1rem; border-radius: 0 8px 8px 8px; margin-bottom: 1rem; }
    .tomorrow-banner h2 { color: #856404; margin-bottom: 0.5rem; font-size: 1.2rem; }
    .tomorrow-banner p { color: #856404; margin: 0.25rem 0; font-size: 0.9rem; }

    /* Table Styles */
    .table-container { max-height: 600px; overflow: auto; }
    .edit-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
    .edit-table th, .edit-table td { padding: 0.5rem; text-align: left; border: 1px solid #ddd; vertical-align: top; }
    .edit-table th { background: #f8f9fa; font-weight: 600; position: sticky; top: 0; z-index: 10; white-space: nowrap; }
    .edit-table tr:hover { background: #f8f9fa; }
    .row-skill-flag { background: #e9f7ef; }

    /* Badges - colors are dynamically generated from MODALITY_SETTINGS */
    .badge { display: inline-block; padding: 0.2rem 0.4rem; margin: 0.1rem; border-radius: 3px; font-size: 0.7rem; font-weight: 600; }
    .badge-default { background: #6c757d; color: white; }

    /* Skill cells */
    .skill-cell { text-align: center; font-size: 0.7rem; }
    .skill-val { padding: 0.2rem 0.4rem; border-radius: 3px; font-size: 0.75rem; }
    .skill-val-1 { background: #d4edda; color: #155724; }
    .skill-val-0 { background: #fff3cd; color: #856404; }
    .skill-val--1 { background: #f8d7da; color: #721c24; }

    /* Aggregated skill/modality cells */
    .agg-cell { text-align: center; font-size: 0.7rem; min-width: 50px; }
    .agg-val { padding: 0.3rem 0.5rem; border-radius: 3px; font-size: 0.75rem; display: inline-block; min-width: 30px; }
    .agg-all-1 { background: #28a745; color: white; }       /* All = 1: Full green */
    .agg-any-1 { background: #8fd19e; color: #155724; }     /* Any = 1: Light green */
    .agg-all-0 { background: #ffc107; color: #333; }        /* All = 0: Yellow */
    .agg-any-0 { background: #ffe69c; color: #856404; }     /* Any = 0: Light yellow */
    .agg-all-neg { background: #dc3545; color: white; }     /* All = -1: Red */
    .agg-mixed { background: #e9ecef; color: #495057; }     /* Mixed values */

    /* Skill value 2/'w' = weighted (visual marker only) */
    .skill-val-2 { background: #17a2b8; color: white; }
    .agg-has-weighted { border: 2px solid #17a2b8; }

    /* Workload modifier badge */
    .modifier-badge { display: inline-block; padding: 0.1rem 0.3rem; border-radius: 3px; font-size: 0.65rem; font-weight: 600; margin-left: 0.3rem; }
    .modifier-high { background: #17a2b8; color: white; }    /* Modifier > 1: higher weight */
    .modifier-low { background: #6f42c1; color: white; }     /* Modifier < 1: lower weight (freshman) */

    /* View toggle */
    .view-toggle { display: flex; gap: 0; border: 2px solid #004892; border-radius: 6px; overflow: hidden; }
    .view-toggle-btn { padding: 0.4rem 1rem; border: none; background: white; color: #004892; font-size: 0.85rem; font-weight: 600; cursor: pointer; transition: all 0.2s; }
    .view-toggle-btn:hover { background: #e9ecef; }
    .view-toggle-btn.active { background: #004892; color: white; }
    .view-toggle-container { display: flex; align-items: center; gap: 0.75rem; }

    /* Duplicate worker indicator */
    .worker-name { font-weight: 500; }
    .worker-name.duplicate { position: relative; }
    .worker-name.duplicate::after { content: '★'; color: #ffc107; margin-left: 0.3rem; font-size: 0.8rem; }
    .duplicate-badge { background: #ffc107; color: #333; padding: 0.1rem 0.3rem; border-radius: 3px; font-size: 0.65rem; margin-left: 0.3rem; font-weight: 600; }

    /* Shift time display */
    .shift-time { font-family: monospace; font-size: 0.85rem; }

    /* Task badges */
    .task-badge { display: inline-block; padding: 0.15rem 0.4rem; margin: 0.1rem; border-radius: 3px; font-size: 0.7rem; background: #e9ecef; color: #495057; }
    .task-badge.exclusion { background: #f8d7da; color: #721c24; }

    /* Buttons */
    .btn { padding: 0.4rem 0.8rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem; font-weight: 600; }
    .btn-primary { background: #004892; color: white; }
    .btn-primary:hover { background: #003670; }
    .btn-secondary { background: #6c757d; color: white; }
    .btn-secondary:hover { background: #5a6268; }
    .btn-success { background: #28a745; color: white; }
    .btn-success:hover { background: #218838; }
    .btn-warning { background: #ffc107; color: #333; }
    .btn-warning:hover { background: #e0a800; }
    .btn-danger { background: #dc3545; color: white; }
    .btn-danger:hover { background: #c82333; }
    .btn-small { padding: 0.2rem 0.4rem; font-size: 0.7rem; }

    /* Message */
    .message { padding: 1rem; border-radius: 4px; margin-bottom: 1rem; display: none; }
    .message.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; display: block; }
    .message.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; display: block; }

    /* Add Panel */
    .add-panel { background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; border: 2px solid #28a745; }
    .add-panel.tomorrow { border-color: #ffc107; }
    .add-panel h4 { margin: 0 0 0.75rem 0; color: #28a745; font-size: 1rem; }
    .add-panel.tomorrow h4 { color: #856404; }
    .add-row { display: flex; gap: 0.75rem; flex-wrap: wrap; align-items: flex-end; }
    .add-row .form-group { display: flex; flex-direction: column; }
    .add-row .form-group label { font-size: 0.75rem; font-weight: 600; margin-bottom: 0.2rem; color: #666; }
    .add-row select, .add-row input { padding: 0.4rem; border: 1px solid #ccc; border-radius: 4px; font-size: 0.85rem; }

    /* Modal */
    .modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center; }
    .modal-overlay.show { display: flex; }
    .modal { background: white; padding: 1.5rem; border-radius: 8px; max-width: 700px; width: 95%; max-height: 85vh; overflow-y: auto; }
    .modal h3 { margin: 0 0 1rem 0; }
    .modal-actions { margin-top: 1rem; display: flex; gap: 0.5rem; justify-content: flex-end; }

    /* Worker group separator in table */
    .worker-group-first td { border-top: 2px solid #004892; }

    /* Dropdown select */
    .worker-select { padding: 0.3rem; border: 1px solid #ccc; border-radius: 3px; font-size: 0.8rem; max-width: 150px; }

    /* Action buttons cell */
    .action-cell { white-space: nowrap; }
    .action-cell .btn { margin: 0.1rem; }
  </style>
</head>
<body>
  <div class="header">
    <div>
      <h1>RadIMO Cortex | Change Today / Prep Tomorrow</h1>
      <p style="font-size: 0.85rem; opacity: 0.9;">Manage current schedule or prepare tomorrow's schedule</p>
    </div>
    <div class="header-actions">
      <a href="{{ url_for('index') }}">Dashboard</a>
      <a href="{{ url_for('timetable') }}">Timetable</a>
      <a href="{{ url_for('skill_roster_page') }}">Skill Matrix</a>
      <a href="{{ url_for('upload_file') }}">Upload</a>
      <a href="{{ url_for('logout') }}">Logout</a>
    </div>
  </div>

  <div id="message-container"></div>

  <!-- Tab Navigation -->
  <div class="tab-container">
    <button class="tab-btn active-today" onclick="switchTab('today')" id="tab-today">Change Today</button>
    <button class="tab-btn" onclick="switchTab('tomorrow')" id="tab-tomorrow">Prep Tomorrow</button>
  </div>

  <!-- TODAY TAB -->
  <div id="content-today" class="tab-content active">
    <div class="today-banner">
      <h2>LIVE CHANGES - Immediate Effect</h2>
      <p>Changes here apply IMMEDIATELY to today's schedule. <strong>Counters are NOT reset.</strong></p>
    </div>

    <div class="card" style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: center;">
      <strong>Load Today from CSV:</strong>
      <button class="btn btn-success" onclick="loadFromCSV('today')">Load Today</button>
      <span id="load-status-today" style="color: #666;"></span>
    </div>

    <div class="card">
      <!-- Add Worker Panel -->
      <div class="add-panel">
        <h4>+ Add Worker</h4>
        <div class="add-row">
          <div class="form-group">
            <label>Worker</label>
            <select id="add-worker-today" onchange="onWorkerChange('today')" style="min-width: 180px;">
              <option value="">-- Select Worker --</option>
              {% for worker in worker_list %}
              <option value="{{ worker }}">{{ worker }}</option>
              {% endfor %}
            </select>
          </div>
          <div class="form-group">
            <label>Task/Role</label>
            <select id="add-task-today" onchange="onTaskChange('today')" style="min-width: 180px;">
              <option value="">-- Select Task --</option>
              {% for task in task_roles|default([]) %}
              <option value="{{ task.name }}" data-modalities="{{ task.modalities|tojson }}" data-shift="{{ task.shift }}" data-skills="{{ task.base_skills|tojson }}" data-modifier="{{ task.modifier|default(1.0) }}">{{ task.name }}</option>
              {% endfor %}
            </select>
          </div>
          <div class="form-group" id="modality-select-today" style="display: none;">
            <label>Modality</label>
            <select id="add-modality-today">
              {% for mod in modalities %}
              <option value="{{ mod }}">{{ mod|upper }}</option>
              {% endfor %}
            </select>
          </div>
          <button class="btn btn-success" onclick="addWorker('today')">Add</button>
        </div>
        <!-- Expandable Time & Skills Section -->
        <div id="add-options-today" style="display: none; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e0e0e0;">
          <div style="display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: flex-start;">
            <div class="form-group">
              <label>Start Time</label>
              <input type="time" id="add-start-time-today" value="07:00" style="padding: 0.3rem;">
            </div>
            <div class="form-group">
              <label>End Time</label>
              <input type="time" id="add-end-time-today" value="15:00" style="padding: 0.3rem;">
            </div>
            <div class="form-group">
              <label>Modifier</label>
              <select id="add-modifier-today" style="padding: 0.3rem;">
                <option value="0.5">0.5x</option>
                <option value="0.75">0.75x</option>
                <option value="1.0" selected>1.0x</option>
                <option value="1.25">1.25x</option>
                <option value="1.5">1.5x</option>
              </select>
            </div>
          </div>
          <div style="margin-top: 0.5rem;">
            <label style="font-size: 0.85rem; font-weight: 500;">Skills:</label>
            <div id="add-skills-today" style="display: flex; gap: 0.75rem; flex-wrap: wrap; margin-top: 0.25rem;">
              {% for skill in skills %}
              <div style="display: flex; align-items: center; gap: 0.25rem;">
                <select id="add-skill-{{ skill }}-today" style="padding: 0.2rem; font-size: 0.8rem; width: 50px;">
                  <option value="-1">-1</option>
                  <option value="0" selected>0</option>
                  <option value="1">1</option>
                  <option value="2">w</option>
                </select>
                <span style="font-size: 0.75rem;">{{ skill }}</span>
              </div>
              {% endfor %}
            </div>
          </div>
        </div>
      </div>

      <!-- View Toggle -->
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 0.5rem;">
        <div class="view-toggle-container">
          <span style="font-size: 0.85rem; color: #666;">View by:</span>
          <div class="view-toggle">
            <button class="view-toggle-btn active" onclick="setViewMode('today', 'skills')" id="view-skills-today">Skills</button>
            <button class="view-toggle-btn" onclick="setViewMode('today', 'modalities')" id="view-modalities-today">Modalities</button>
          </div>
        </div>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
          <button class="btn btn-secondary" onclick="toggleEditMode('today')" id="edit-mode-btn-today">Quick Edit</button>
          <button class="btn btn-success" onclick="saveInlineChanges('today')" id="save-inline-btn-today" style="display: none;">Save Changes</button>
        </div>
        <div style="font-size: 0.75rem; color: #666;">
          <span class="agg-val agg-all-1">■</span> All=1
          <span class="agg-val agg-any-1">■</span> Any=1
          <span class="agg-val agg-all-0">■</span> All=0
          <span class="agg-val agg-all-neg">■</span> All=-1
          <span class="agg-val skill-val-2">2</span> Weighted
        </div>
      </div>

      <!-- Worker Table - One row per entry -->
      <div class="table-container">
        <table class="edit-table" id="edit-table-today">
          <thead id="table-head-today">
            <tr>
              <th>Worker</th>
              <th>Modality</th>
              <th>Shift</th>
              {% for skill in skills %}
              <th class="skill-cell">{{ skill }}</th>
              {% endfor %}
              <th>Task</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="table-body-today"></tbody>
        </table>
      </div>
      <p style="margin-top: 0.5rem; font-size: 0.75rem; color: #666;">★ = Worker has multiple entries (double shift)</p>
    </div>
  </div>

  <!-- TOMORROW TAB -->
  <div id="content-tomorrow" class="tab-content">
    <div class="tomorrow-banner">
      <h2>STAGING MODE - Prep for Tomorrow</h2>
      <p>Changes are saved to STAGED area for tomorrow. <strong>Counter reset happens on CSV import.</strong></p>
    </div>

    <div class="card" style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: center;">
      <strong>Load Next Day from CSV:</strong>
      <button class="btn btn-warning" onclick="loadFromCSV('next')">Load Next Day</button>
      <span id="load-status-tomorrow" style="color: #666;"></span>
    </div>

    <div class="card">
      <!-- Add Worker Panel -->
      <div class="add-panel tomorrow">
        <h4>+ Add Worker</h4>
        <div class="add-row">
          <div class="form-group">
            <label>Worker Name</label>
            <input type="text" id="add-worker-input" placeholder="e.g. Dr. Müller" style="width: 200px;" list="worker-list-datalist" autocomplete="off" onchange="onWorkerChange('tomorrow')" oninput="onWorkerChange('tomorrow')">
            <datalist id="worker-list-datalist">
              {% for worker in worker_list %}
              <option value="{{ worker }}">
              {% endfor %}
            </datalist>
          </div>
          <div class="form-group">
            <label>Task/Role</label>
            <select id="add-task-tomorrow" onchange="onTaskChange('tomorrow')" style="min-width: 180px;">
              <option value="">-- Select Task --</option>
              {% for task in task_roles|default([]) %}
              <option value="{{ task.name }}" data-modalities="{{ task.modalities|tojson }}" data-shift="{{ task.shift }}" data-skills="{{ task.base_skills|tojson }}" data-modifier="{{ task.modifier|default(1.0) }}">{{ task.name }}</option>
              {% endfor %}
            </select>
          </div>
          <div class="form-group" id="modality-select-tomorrow" style="display: none;">
            <label>Modality</label>
            <select id="add-modality-tomorrow">
              {% for mod in modalities %}
              <option value="{{ mod }}">{{ mod|upper }}</option>
              {% endfor %}
            </select>
          </div>
          <button class="btn btn-warning" onclick="addWorker('tomorrow')">Add</button>
        </div>
        <!-- Expandable Time & Skills Section -->
        <div id="add-options-tomorrow" style="display: none; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e0e0e0;">
          <div style="display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: flex-start;">
            <div class="form-group">
              <label>Start Time</label>
              <input type="time" id="add-start-time-tomorrow" value="07:00" style="padding: 0.3rem;">
            </div>
            <div class="form-group">
              <label>End Time</label>
              <input type="time" id="add-end-time-tomorrow" value="15:00" style="padding: 0.3rem;">
            </div>
            <div class="form-group">
              <label>Modifier</label>
              <select id="add-modifier-tomorrow" style="padding: 0.3rem;">
                <option value="0.5">0.5x</option>
                <option value="0.75">0.75x</option>
                <option value="1.0" selected>1.0x</option>
                <option value="1.25">1.25x</option>
                <option value="1.5">1.5x</option>
              </select>
            </div>
          </div>
          <div style="margin-top: 0.5rem;">
            <label style="font-size: 0.85rem; font-weight: 500;">Skills:</label>
            <div id="add-skills-tomorrow" style="display: flex; gap: 0.75rem; flex-wrap: wrap; margin-top: 0.25rem;">
              {% for skill in skills %}
              <div style="display: flex; align-items: center; gap: 0.25rem;">
                <select id="add-skill-{{ skill }}-tomorrow" style="padding: 0.2rem; font-size: 0.8rem; width: 50px;">
                  <option value="-1">-1</option>
                  <option value="0" selected>0</option>
                  <option value="1">1</option>
                  <option value="2">w</option>
                </select>
                <span style="font-size: 0.75rem;">{{ skill }}</span>
              </div>
              {% endfor %}
            </div>
          </div>
        </div>
      </div>

      <!-- View Toggle -->
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 0.5rem;">
        <div class="view-toggle-container">
          <span style="font-size: 0.85rem; color: #666;">View by:</span>
          <div class="view-toggle">
            <button class="view-toggle-btn active" onclick="setViewMode('tomorrow', 'skills')" id="view-skills-tomorrow">Skills</button>
            <button class="view-toggle-btn" onclick="setViewMode('tomorrow', 'modalities')" id="view-modalities-tomorrow">Modalities</button>
          </div>
        </div>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
          <button class="btn btn-secondary" onclick="toggleEditMode('tomorrow')" id="edit-mode-btn-tomorrow">Quick Edit</button>
          <button class="btn btn-success" onclick="saveInlineChanges('tomorrow')" id="save-inline-btn-tomorrow" style="display: none;">Save Changes</button>
        </div>
        <div style="font-size: 0.75rem; color: #666;">
          <span class="agg-val agg-all-1">■</span> All=1
          <span class="agg-val agg-any-1">■</span> Any=1
          <span class="agg-val agg-all-0">■</span> All=0
          <span class="agg-val agg-all-neg">■</span> All=-1
          <span class="agg-val skill-val-2">2</span> Weighted
        </div>
      </div>

      <!-- Worker Table - One row per entry -->
      <div class="table-container">
        <table class="edit-table" id="edit-table-tomorrow">
          <thead id="table-head-tomorrow">
            <tr>
              <th>Worker</th>
              <th>Modality</th>
              <th>Shift</th>
              {% for skill in skills %}
              <th class="skill-cell">{{ skill }}</th>
              {% endfor %}
              <th>Task</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="table-body-tomorrow"></tbody>
        </table>
      </div>
      <p style="margin-top: 0.5rem; font-size: 0.75rem; color: #666;">★ = Worker has multiple entries (double shift)</p>
    </div>
  </div>

  <!-- Edit Modal -->
  <div class="modal-overlay" id="edit-modal">
    <div class="modal">
      <h3 id="modal-title">Edit Worker</h3>
      <div id="modal-content"></div>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveModalChanges()">Save</button>
      </div>
    </div>
  </div>


  <script>
    // Configuration from backend
    const SKILLS = {{ skills|default([])|tojson }};
    const MODALITIES = {{ modalities|default([])|tojson }};
    const MODALITY_SETTINGS = {{ modality_settings|default({})|tojson }};
    const SHIFT_TIMES = {{ shift_times|default({})|tojson }};
    const WORKER_SKILLS = {{ worker_skills|default({})|tojson }};
    const TASK_ROLES = {{ task_roles|default([])|tojson }};
    const EXCLUSION_RULES = {{ exclusion_rules|default([])|tojson }};

    // Generate dynamic CSS for modality colors from config
    (function() {
      const style = document.createElement('style');
      let css = '';
      for (const [mod, settings] of Object.entries(MODALITY_SETTINGS)) {
        const navColor = settings.nav_color || '#6c757d';
        const bgColor = settings.background_color || '#f8f9fa';
        css += `.badge-${mod} { background: ${navColor}; color: white; }\n`;
        css += `.modality-border-${mod} { border-color: ${navColor}; }\n`;
        css += `.modality-bg-${mod} { background: ${bgColor}; }\n`;
      }
      style.textContent = css;
      document.head.appendChild(style);
    })();

    // State
    let currentTab = 'today';
    let rawData = { today: {}, tomorrow: {} };  // Raw modality data
    let entriesData = { today: [], tomorrow: [] };  // Grouped by worker -> entries
    let workerCounts = { today: {}, tomorrow: {} };  // Count entries per worker for duplicate detection
    let currentEditEntry = null;
    let dataLoaded = { today: false, tomorrow: false };  // Track which tabs have been loaded
    let viewMode = { today: 'skills', tomorrow: 'skills' };  // View mode: 'skills' or 'modalities'
    let editMode = { today: false, tomorrow: false };  // Inline edit mode
    let pendingChanges = { today: {}, tomorrow: {} };  // Track unsaved inline changes

    // Set view mode and re-render
    function setViewMode(tab, mode) {
      viewMode[tab] = mode;

      // Update toggle buttons
      document.getElementById(`view-skills-${tab}`).className = mode === 'skills' ? 'view-toggle-btn active' : 'view-toggle-btn';
      document.getElementById(`view-modalities-${tab}`).className = mode === 'modalities' ? 'view-toggle-btn active' : 'view-toggle-btn';

      // Re-render the table
      renderTable(tab);
    }

    // Toggle inline edit mode
    function toggleEditMode(tab) {
      editMode[tab] = !editMode[tab];
      pendingChanges[tab] = {};  // Reset pending changes

      // Update button
      const btn = document.getElementById(`edit-mode-btn-${tab}`);
      if (btn) {
        btn.textContent = editMode[tab] ? 'Exit Edit Mode' : 'Quick Edit';
        btn.className = editMode[tab] ? 'btn btn-warning' : 'btn btn-secondary';
      }

      // Show/hide save button
      const saveBtn = document.getElementById(`save-inline-btn-${tab}`);
      if (saveBtn) {
        saveBtn.style.display = editMode[tab] ? 'inline-block' : 'none';
      }

      renderTable(tab);
    }

    // Track inline skill change
    function onInlineSkillChange(tab, modKey, rowIndex, skill, value) {
      const key = `${modKey}-${rowIndex}`;
      if (!pendingChanges[tab][key]) {
        pendingChanges[tab][key] = { modality: modKey, row_index: rowIndex, updates: {} };
      }
      pendingChanges[tab][key].updates[skill] = parseInt(value);

      // Update save button count
      const count = Object.keys(pendingChanges[tab]).length;
      const saveBtn = document.getElementById(`save-inline-btn-${tab}`);
      if (saveBtn) {
        saveBtn.textContent = `Save ${count} change${count > 1 ? 's' : ''}`;
      }
    }

    // Save all inline changes
    async function saveInlineChanges(tab) {
      const changes = Object.values(pendingChanges[tab]);
      if (changes.length === 0) {
        showMessage('error', 'No changes to save');
        return;
      }

      const endpoint = tab === 'today' ? '/api/live-schedule/update-row' : '/api/prep-next-day/update-row';

      try {
        for (const change of changes) {
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(change)
          });

          if (!response.ok) {
            const result = await response.json();
            throw new Error(result.error || 'Failed to update');
          }
        }

        showMessage('success', `Saved ${changes.length} change${changes.length > 1 ? 's' : ''}`);
        pendingChanges[tab] = {};
        await loadData();
      } catch (error) {
        showMessage('error', error.message);
      }
    }

    // Calculate aggregated proficiency class for a set of values
    // Priority: Positive (1) values lead the coloring over negative (-1) values
    function getAggregatedClass(values) {
      if (!values || values.length === 0) return 'agg-mixed';

      const allOne = values.every(v => v === 1 || v === 2);  // Include skill=2 (weighted/freshman)
      const anyOne = values.some(v => v === 1 || v === 2);
      const allZero = values.every(v => v === 0);
      const anyZero = values.some(v => v === 0);
      const allNeg = values.every(v => v === -1);

      // Positive values take priority - if any positive, show green colors
      if (allOne) return 'agg-all-1';
      if (anyOne) return 'agg-any-1';  // Any positive wins over negatives
      if (allZero) return 'agg-all-0';
      if (anyZero) return 'agg-any-0';
      if (allNeg) return 'agg-all-neg';
      return 'agg-mixed';
    }

    // Get display value for aggregated cell
    function getAggregatedDisplay(values) {
      if (!values || values.length === 0) return '-';
      const allSame = values.every(v => v === values[0]);
      if (allSame) return values[0];
      // Show unique values sorted (2, 1, 0, -1)
      const unique = [...new Set(values)].sort((a, b) => b - a);
      return unique.join('/');
    }

    // Check if values contain weighted entries (skill=2)
    function hasWeightedEntries(values) {
      return values && values.some(v => v === 2);
    }

    // Utility: Escape HTML to prevent XSS
    function escapeHtml(text) {
      if (text === null || text === undefined) return '';
      const div = document.createElement('div');
      div.textContent = String(text);
      return div.innerHTML;
    }

    // Tab switching with lazy loading
    async function switchTab(tab) {
      currentTab = tab;
      document.getElementById('tab-today').className = tab === 'today' ? 'tab-btn active-today' : 'tab-btn';
      document.getElementById('tab-tomorrow').className = tab === 'tomorrow' ? 'tab-btn active-tomorrow' : 'tab-btn';
      document.getElementById('content-today').className = tab === 'today' ? 'tab-content active' : 'tab-content';
      document.getElementById('content-tomorrow').className = tab === 'tomorrow' ? 'tab-content active' : 'tab-content';

      // Lazy load data for the selected tab if not already loaded
      if (!dataLoaded[tab]) {
        await loadTabData(tab);
      }
    }

    // Load data for a specific tab (lazy loading)
    async function loadTabData(tab) {
      try {
        const endpoint = tab === 'today' ? '/api/live-schedule/data' : '/api/prep-next-day/data';
        const response = await fetch(endpoint);

        if (!response.ok) {
          const text = await response.text();
          console.error(`${tab} API error:`, text);
          rawData[tab] = {};
        } else {
          const contentType = response.headers.get('content-type');
          if (contentType && contentType.includes('application/json')) {
            rawData[tab] = await response.json();
          } else {
            console.error(`${tab} API returned non-JSON`);
            rawData[tab] = {};
          }
        }

        const result = buildEntriesByWorker(rawData[tab]);
        entriesData[tab] = result.entries;
        workerCounts[tab] = result.counts;
        dataLoaded[tab] = true;

        renderTable(tab);
      } catch (error) {
        console.error(`Load error for ${tab}:`, error);
        showMessage('error', `Error loading ${tab} data: ${error.message}`);
      }
    }

    // Load data for both tabs (used after mutations)
    async function loadData() {
      // Reset loaded flags to force refresh
      dataLoaded.today = false;
      dataLoaded.tomorrow = false;

      // Load current tab first (visible to user)
      await loadTabData(currentTab);

      // Load other tab in background
      const otherTab = currentTab === 'today' ? 'tomorrow' : 'today';
      loadTabData(otherTab);  // Don't await - load in background
    }

    // Build grouped entries list (per worker, then per modality) and count workers for duplicate detection
    function buildEntriesByWorker(data) {
      const counts = {};
      const grouped = {};

      MODALITIES.forEach(mod => {
        const modData = data[mod] || [];
        modData.forEach(row => {
          const workerName = row.PPL;
          counts[workerName] = (counts[workerName] || 0) + 1;

          // Parse task - handle both string and array formats
          let taskStr = row.tasks || '';
          if (Array.isArray(taskStr)) {
            taskStr = taskStr.filter(t => t && t.trim()).join(', ');
          }

          const entry = {
            worker: workerName,
            modality: mod,
            row_index: row.row_index,
            start_time: row.start_time,
            end_time: row.end_time,
            modifier: row.Modifier !== undefined ? row.Modifier : 1.0,  // Workload modifier
            skills: SKILLS.reduce((acc, skill) => {
              acc[skill] = row[skill] !== undefined ? row[skill] : 0;
              return acc;
            }, {}),
            task: taskStr
          };

          if (!grouped[workerName]) {
            grouped[workerName] = { worker: workerName, entries: [], byModality: {} };
          }
          grouped[workerName].entries.push(entry);

          // Also group by modality for the new view
          const modKey = mod.toLowerCase();
          if (!grouped[workerName].byModality[modKey]) {
            grouped[workerName].byModality[modKey] = [];
          }
          grouped[workerName].byModality[modKey].push(entry);
        });
      });

      // Sort entries within each worker by modality then start time
      Object.values(grouped).forEach(group => {
        group.entries.sort((a, b) => {
          const modCompare = (a.modality || '').localeCompare(b.modality || '');
          if (modCompare !== 0) return modCompare;
          return (a.start_time || '').localeCompare(b.start_time || '');
        });
      });

      // Sort workers alphabetically
      const entries = Object.values(grouped).sort((a, b) => a.worker.localeCompare(b.worker));

      return { entries, counts };
    }

    // Render table header based on view mode
    function renderTableHeader(tab) {
      const thead = document.getElementById(`table-head-${tab}`);
      const mode = viewMode[tab];

      let headerHtml = '<tr><th>Worker</th>';

      if (mode === 'skills') {
        // Skills view: Worker | Modality | Time Slots | Skills... | Actions
        headerHtml += '<th>Modality</th>';
        headerHtml += '<th>Time Slots</th>';
        SKILLS.forEach(skill => {
          headerHtml += `<th class="skill-cell">${escapeHtml(skill)}</th>`;
        });
      } else {
        // Modalities view: Worker | Entries | Modalities... | Actions
        headerHtml += '<th>Entries</th>';
        MODALITIES.forEach(mod => {
          headerHtml += `<th class="agg-cell">${escapeHtml(mod.toUpperCase())}</th>`;
        });
      }

      headerHtml += '<th>Actions</th></tr>';
      thead.innerHTML = headerHtml;
    }

    // Render grouped table by worker
    function renderTable(tab) {
      // First update the header
      renderTableHeader(tab);

      const tbody = document.getElementById(`table-body-${tab}`);
      tbody.innerHTML = '';

      const groups = entriesData[tab];
      const counts = workerCounts[tab];
      const mode = viewMode[tab];

      const colCount = mode === 'skills' ? 4 + SKILLS.length : 3 + MODALITIES.length;

      if (!groups || groups.length === 0) {
        tbody.innerHTML = `<tr><td colspan="${colCount}" style="text-align: center; padding: 2rem; color: #666;">No data. Load from CSV first.</td></tr>`;
        return;
      }

      groups.forEach((group, gIdx) => {
        const isDuplicate = counts[group.worker] > 1;
        const escapedWorker = escapeHtml(group.worker);
        const duplicateBadge = isDuplicate ? `<span class="duplicate-badge">${counts[group.worker]}x</span>` : '';

        // Build modality -> entry map for this worker
        const modalityEntries = group.byModality || {};

        if (mode === 'skills') {
          // Skills view: One row per modality for this worker
          // Get list of modalities this worker has
          const workerModalities = Object.keys(modalityEntries).sort();
          const numModalities = workerModalities.length;

          workerModalities.forEach((modKey, modIdx) => {
            const modEntries = modalityEntries[modKey] || [];
            if (modEntries.length === 0) return;

            const tr = document.createElement('tr');
            // Add visual separator for first row of each worker
            if (modIdx === 0) {
              tr.classList.add('worker-group-first');
            }

            // Worker name (only on first row, with rowspan)
            if (modIdx === 0) {
              tr.innerHTML += `<td rowspan="${numModalities}" style="vertical-align: middle;"><span class="worker-name ${isDuplicate ? 'duplicate' : ''}">${escapedWorker}</span>${duplicateBadge}</td>`;
            }

            // Modality badge
            const badgeClass = `badge-${modKey}`;
            tr.innerHTML += `<td><span class="badge ${badgeClass}">${escapeHtml(modKey.toUpperCase())}</span></td>`;

            // Time slots column: show all shifts for this modality (double shifts)
            let timeSlotsHtml = '<td style="max-width: 180px;">';
            modEntries.forEach((entry, eIdx) => {
              const timeStr = `${escapeHtml(entry.start_time)}-${escapeHtml(entry.end_time)}`;
              // Show modifier badge if not 1.0
              let modifierBadge = '';
              if (entry.modifier && entry.modifier !== 1.0) {
                const modClass = entry.modifier < 1.0 ? 'modifier-low' : 'modifier-high';
                modifierBadge = `<span class="modifier-badge ${modClass}">${entry.modifier}x</span>`;
              }
              timeSlotsHtml += `<div style="margin: 1px 0;"><span class="shift-time">${timeStr}</span>${modifierBadge}</div>`;
            });
            timeSlotsHtml += '</td>';
            tr.innerHTML += timeSlotsHtml;

            // Skill columns: use first entry's skills (all entries in same modality should have same skills)
            // In edit mode, show dropdown selects
            const firstEntry = modEntries[0];
            const isEditMode = editMode[tab];

            SKILLS.forEach(skill => {
              const values = modEntries.map(entry => entry.skills[skill]);
              const allSame = values.every(v => v === values[0]);
              const val = values[0];

              if (isEditMode) {
                // Edit mode: show dropdown
                tr.innerHTML += `<td class="skill-cell">
                  <select onchange="onInlineSkillChange('${tab}', '${modKey}', ${firstEntry.row_index}, '${skill}', this.value)" style="padding: 0.15rem; font-size: 0.75rem; width: 40px;">
                    <option value="-1" ${val === -1 ? 'selected' : ''}>-1</option>
                    <option value="0" ${val === 0 ? 'selected' : ''}>0</option>
                    <option value="1" ${val === 1 ? 'selected' : ''}>1</option>
                    <option value="2" ${val === 2 ? 'selected' : ''}>w</option>
                  </select>
                </td>`;
              } else if (allSame) {
                const skillClass = val === 2 ? 'skill-val-2' : `skill-val-${val}`;
                const displayVal = val === 2 ? 'w' : val;
                tr.innerHTML += `<td class="skill-cell"><span class="skill-val ${skillClass}">${displayVal}</span></td>`;
              } else {
                // Different values across time slots - show aggregated
                const aggClass = getAggregatedClass(values);
                const displayVal = getAggregatedDisplay(values);
                tr.innerHTML += `<td class="skill-cell"><span class="agg-val ${aggClass}">${displayVal}</span></td>`;
              }
            });

            // Actions (only on first row, with rowspan)
            if (modIdx === 0) {
              tr.innerHTML += `
                <td rowspan="${numModalities}" class="action-cell" style="vertical-align: middle;">
                  <button class="btn btn-small btn-primary" onclick="openEditModal('${tab}', ${gIdx})" title="Edit">Edit</button>
                  <button class="btn btn-small btn-danger" onclick="deleteWorkerEntries('${tab}', ${gIdx})" title="Delete All">Del</button>
                </td>`;
            }

            tbody.appendChild(tr);
          });

        } else {
          // Modalities view: One row per worker, aggregate modalities across all skills
          const tr = document.createElement('tr');
          tr.classList.add('worker-group-first');

          // Worker name
          tr.innerHTML += `<td><span class="worker-name ${isDuplicate ? 'duplicate' : ''}">${escapedWorker}</span>${duplicateBadge}</td>`;

          // Entries column: show all shifts as badges with modifier
          let entriesHtml = '<td style="max-width: 250px;">';
          group.entries.forEach((entry, eIdx) => {
            const modKey = (entry.modality || '').toString().toLowerCase();
            const badgeClass = modKey ? `badge-${modKey}` : 'badge-default';
            const modalityLabel = escapeHtml(entry.modality ? entry.modality.toUpperCase() : '-');
            const timeStr = `${escapeHtml(entry.start_time)}-${escapeHtml(entry.end_time)}`;
            // Show modifier badge if not 1.0
            let modifierBadge = '';
            if (entry.modifier && entry.modifier !== 1.0) {
              const modClass = entry.modifier < 1.0 ? 'modifier-low' : 'modifier-high';
              modifierBadge = `<span class="modifier-badge ${modClass}">${entry.modifier}x</span>`;
            }
            entriesHtml += `<div style="margin: 2px 0;"><span class="badge ${badgeClass}">${modalityLabel}</span> <span style="font-size: 0.7rem; color: #666;">${timeStr}</span>${modifierBadge}</div>`;
          });
          entriesHtml += '</td>';
          tr.innerHTML += entriesHtml;

          // Modality columns: aggregate all skills for each modality
          MODALITIES.forEach(mod => {
            const modKey = mod.toLowerCase();
            const modEntries = modalityEntries[modKey] || [];

            if (modEntries.length === 0) {
              // Worker doesn't have this modality
              tr.innerHTML += `<td class="agg-cell"><span class="agg-val" style="background: #f8f9fa; color: #999;">-</span></td>`;
            } else {
              // Aggregate all skills for this modality across all entries
              const values = [];
              modEntries.forEach(entry => {
                SKILLS.forEach(skill => {
                  values.push(entry.skills[skill]);
                });
              });
              const aggClass = getAggregatedClass(values);
              const allOne = values.every(v => v === 1);
              const allNeg = values.every(v => v === -1);
              const allZero = values.every(v => v === 0);
              let displayVal = '●';  // Show a dot instead of values
              if (allOne) displayVal = '✓';
              else if (allNeg) displayVal = '✗';
              else if (allZero) displayVal = '○';
              tr.innerHTML += `<td class="agg-cell"><span class="agg-val ${aggClass}">${displayVal}</span></td>`;
            }
          });

          // Actions
          tr.innerHTML += `
            <td class="action-cell">
              <button class="btn btn-small btn-primary" onclick="openEditModal('${tab}', ${gIdx})" title="Edit">Edit</button>
              <button class="btn btn-small btn-danger" onclick="deleteWorkerEntries('${tab}', ${gIdx})" title="Delete All">Del</button>
            </td>`;

          tbody.appendChild(tr);
        }
      });
    }

    // Delete all entries for a worker
    async function deleteWorkerEntries(tab, groupIdx) {
      const group = entriesData[tab][groupIdx];
      if (!group) return;

      if (!confirm(`Delete all ${group.entries.length} entries for ${group.worker}?`)) return;

      const endpoint = tab === 'today' ? '/api/live-schedule/delete-worker' : '/api/prep-next-day/delete-worker';

      try {
        // Delete all entries in reverse order (to avoid index shifting issues)
        for (let i = group.entries.length - 1; i >= 0; i--) {
          const entry = group.entries[i];
          await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ modality: entry.modality, row_index: entry.row_index })
          });
        }
        showMessage('success', `Deleted all entries for ${group.worker}`);
        await loadData();
      } catch (error) {
        showMessage('error', error.message);
      }
    }

    // Task dropdown change - auto-select modality (shift comes from task config)
    // Auto-prepull skills from worker roster when worker is selected (if no task selected)
    function onWorkerChange(tab) {
      const workerSelect = document.getElementById(`add-worker-${tab}`);
      const workerInput = document.getElementById('add-worker-input');
      const taskSelect = document.getElementById(`add-task-${tab}`);
      const optionsPanel = document.getElementById(`add-options-${tab}`);

      let workerName = workerSelect ? workerSelect.value : (workerInput ? workerInput.value : '');

      // If no task selected and worker has roster entry, prepull skills from roster
      if (workerName && (!taskSelect.value || taskSelect.value === '')) {
        const preset = WORKER_SKILLS[workerName];
        if (preset) {
          optionsPanel.style.display = 'block';
          const skills = preset.skills || preset;
          SKILLS.forEach(skill => {
            const skillSelect = document.getElementById(`add-skill-${skill}-${tab}`);
            if (skillSelect && skills && skills[skill] !== undefined) {
              // Limit roster presets to 0/-1; positive values reserved for CSV/manual
              const val = skills[skill];
              skillSelect.value = (val > 0 ? 0 : val).toString();
            }
          });
        }
      }
    }

    function onTaskChange(tab) {
      const taskSelect = document.getElementById(`add-task-${tab}`);
      const modalityGroup = document.getElementById(`modality-select-${tab}`);
      const modalitySelect = document.getElementById(`add-modality-${tab}`);
      const optionsPanel = document.getElementById(`add-options-${tab}`);
      const workerSelect = document.getElementById(`add-worker-${tab}`);
      const workerInput = document.getElementById('add-worker-input');

      const option = taskSelect.options[taskSelect.selectedIndex];
      if (!option || !option.value) {
        modalityGroup.style.display = 'none';
        // If no task but worker selected, still show options with worker skills
        const workerName = workerSelect ? workerSelect.value : (workerInput ? workerInput.value : '');
        if (workerName) {
          onWorkerChange(tab);
        } else {
          optionsPanel.style.display = 'none';
        }
        return;
      }

      // Get modalities from data attribute
      const modalities = JSON.parse(option.dataset.modalities || '[]');

      // Show modality dropdown if multiple options
      if (modalities.length > 1) {
        modalityGroup.style.display = 'block';
        modalitySelect.innerHTML = modalities.map(m => `<option value="${m}">${m.toUpperCase()}</option>`).join('');
      } else if (modalities.length === 1) {
        modalityGroup.style.display = 'none';
        modalitySelect.innerHTML = `<option value="${modalities[0]}">${modalities[0].toUpperCase()}</option>`;
      }

      // Show options panel and prefill values from task config
      optionsPanel.style.display = 'block';

      // Prefill times from shift config
      const shiftName = option.dataset.shift || 'Fruehdienst';
      const shiftConfig = SHIFT_TIMES[shiftName] || {};
      const shiftDefault = shiftConfig.default || '07:00-15:00';
      const [startTime, endTime] = shiftDefault.split('-');
      document.getElementById(`add-start-time-${tab}`).value = startTime;
      document.getElementById(`add-end-time-${tab}`).value = endTime;

      // Prefill modifier from task config
      const taskModifier = parseFloat(option.dataset.modifier) || 1.0;
      const modifierSelect = document.getElementById(`add-modifier-${tab}`);
      modifierSelect.value = taskModifier.toString();

      // Prefill skills from task config (auto-apply, no button needed)
      const taskSkills = JSON.parse(option.dataset.skills || '{}');
      SKILLS.forEach(skill => {
        const skillSelect = document.getElementById(`add-skill-${skill}-${tab}`);
        if (skillSelect) {
          const val = taskSkills[skill] !== undefined ? taskSkills[skill] : 0;
          skillSelect.value = val.toString();
        }
      });

      // If worker also selected, merge with worker roster skills (task takes priority for active skills)
      const workerName = workerSelect ? workerSelect.value : (workerInput ? workerInput.value : '');
      if (workerName) {
        const preset = WORKER_SKILLS[workerName];
        if (preset) {
          const rosterSkills = preset.skills || preset;
          SKILLS.forEach(skill => {
            // Only apply roster skill if task didn't set it to active (1 or 2)
            const taskVal = taskSkills[skill];
            if (taskVal === undefined || taskVal <= 0) {
              const skillSelect = document.getElementById(`add-skill-${skill}-${tab}`);
              if (skillSelect && rosterSkills && rosterSkills[skill] !== undefined) {
                const val = rosterSkills[skill];
                // Roster -1 values override task 0 values
                if (val === -1) {
                  skillSelect.value = '-1';
                }
              }
            }
          });
        }
      }
    }

    // Add worker
    async function addWorker(tab) {
      // Get worker name - handle both select and input
      let workerName;
      const workerSelect = document.getElementById(`add-worker-${tab}`);
      const workerInput = document.getElementById('add-worker-input');
      if (workerSelect) {
        workerName = workerSelect.value;
      } else if (workerInput) {
        workerName = workerInput.value;
      }

      const taskSelect = document.getElementById(`add-task-${tab}`);
      const modalitySelect = document.getElementById(`add-modality-${tab}`);

      const taskName = taskSelect.value;
      const modality = modalitySelect.value;

      if (!workerName) { showMessage('error', 'Please enter/select a worker'); return; }
      if (!taskName) { showMessage('error', 'Please select a task/role'); return; }

      // Get times from form fields (user can edit these)
      const startTime = document.getElementById(`add-start-time-${tab}`).value;
      const endTime = document.getElementById(`add-end-time-${tab}`).value;

      // Get modifier from form field (user can edit)
      const modifier = parseFloat(document.getElementById(`add-modifier-${tab}`).value) || 1.0;

      // Get skills from form fields (user can edit these)
      const skills = {};
      SKILLS.forEach(skill => {
        const skillSelect = document.getElementById(`add-skill-${skill}-${tab}`);
        skills[skill] = skillSelect ? parseInt(skillSelect.value) : 0;
      });

      const endpoint = tab === 'today' ? '/api/live-schedule/add-worker' : '/api/prep-next-day/add-worker';

      try {
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            modality,
            worker_data: {
              PPL: workerName,
              start_time: startTime,
              end_time: endTime,
              Modifier: modifier,
              tasks: taskName,
              ...skills
            }
          })
        });

        if (response.ok) {
          showMessage('success', `${workerName} added as ${taskName}`);
          // Reset form
          if (workerSelect) workerSelect.value = '';
          if (workerInput) workerInput.value = '';
          taskSelect.value = '';
          document.getElementById(`modality-select-${tab}`).style.display = 'none';
          document.getElementById(`add-options-${tab}`).style.display = 'none';
          await loadData();
        } else {
          const errData = await response.json().catch(() => ({}));
          showMessage('error', errData.error || 'Failed to add worker');
        }
      } catch (error) {
        showMessage('error', error.message);
      }
    }

    // Delete single entry
    async function deleteEntry(tab, groupIdx, entryIdx) {
      const group = entriesData[tab][groupIdx];
      if (!group) return;
      const entry = group.entries[entryIdx];
      if (!entry) return;

      if (!confirm(`Delete entry for ${entry.worker} (${entry.modality.toUpperCase()} ${entry.start_time}-${entry.end_time})?`)) return;

      const endpoint = tab === 'today' ? '/api/live-schedule/delete-worker' : '/api/prep-next-day/delete-worker';

      try {
        await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ modality: entry.modality, row_index: entry.row_index })
        });
        showMessage('success', `Deleted entry for ${entry.worker}`);
        await loadData();
      } catch (error) {
        showMessage('error', error.message);
      }
    }

    // Open Edit modal for a worker - edit skills per modality
    function openEditModal(tab, groupIdx) {
      const group = entriesData[tab][groupIdx];
      if (!group) return;

      currentEditEntry = { tab, groupIdx };
      renderEditModalContent();
      document.getElementById('edit-modal').classList.add('show');
    }

    function renderEditModalContent() {
      const { tab, groupIdx } = currentEditEntry;
      const group = entriesData[tab][groupIdx];
      if (!group) return;

      let html = '';

      // XSS-safe rendering
      const escapedWorker = escapeHtml(group.worker);
      const duplicateBadge = workerCounts[tab][group.worker] > 1 ? `<span class="duplicate-badge">${workerCounts[tab][group.worker]}x</span>` : '';

      // Header with worker name
      html += `<div style="margin-bottom: 1rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px;">
        <div><strong>${escapedWorker}</strong> ${duplicateBadge}</div>
      </div>`;

      // Get modalities for this worker
      const modalityEntries = group.byModality || {};
      const workerModalities = Object.keys(modalityEntries).sort();

      // Render each modality section
      workerModalities.forEach((modKey, modIdx) => {
        const modEntries = modalityEntries[modKey] || [];
        if (modEntries.length === 0) return;

        const badgeClass = `badge-${modKey}`;
        const modLabel = modKey.toUpperCase();

        html += `<div style="margin-bottom: 1rem; padding: 0.75rem; border: 2px solid ${getModalityColor(modKey)}; border-radius: 8px; background: ${getModalityBgColor(modKey)};">`;

        // Modality header
        html += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
          <span class="badge ${badgeClass}" style="font-size: 0.9rem; padding: 0.3rem 0.6rem;">${modLabel}</span>
          <div style="display: flex; gap: 0.5rem;">
            <button class="btn btn-small btn-secondary" type="button" onclick="applyWorkerSkillPresetForModality('${group.worker.replace(/'/g, "&#39;")}', '${modKey}')">Apply Worker Skills</button>
          </div>
        </div>`;

        // Time slots section (for double shifts)
        html += `<div style="margin-bottom: 0.75rem;">
          <label style="display: block; margin-bottom: 0.25rem; font-size: 0.8rem; font-weight: 600; color: #555;">Time Slots:</label>
          <div style="display: flex; flex-direction: column; gap: 0.25rem;">`;

        modEntries.forEach((entry, eIdx) => {
          const isOnlyEntry = modEntries.length === 1;
          html += `<div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; padding: 0.25rem; background: rgba(255,255,255,0.5); border-radius: 4px;">
            <input type="time" id="edit-${modKey}-${eIdx}-start" value="${entry.start_time || '07:00'}" style="padding: 0.3rem; font-size: 0.85rem;">
            <span>-</span>
            <input type="time" id="edit-${modKey}-${eIdx}-end" value="${entry.end_time || '15:00'}" style="padding: 0.3rem; font-size: 0.85rem;">
            <select id="edit-${modKey}-${eIdx}-modifier" style="padding: 0.25rem; font-size: 0.8rem;">
              <option value="0.5" ${entry.modifier === 0.5 ? 'selected' : ''}>0.5x</option>
              <option value="0.75" ${entry.modifier === 0.75 ? 'selected' : ''}>0.75x</option>
              <option value="1.0" ${!entry.modifier || entry.modifier === 1.0 ? 'selected' : ''}>1.0x</option>
              <option value="1.25" ${entry.modifier === 1.25 ? 'selected' : ''}>1.25x</option>
              <option value="1.5" ${entry.modifier === 1.5 ? 'selected' : ''}>1.5x</option>
            </select>
            <input type="hidden" id="edit-${modKey}-${eIdx}-rowindex" value="${entry.row_index}">
          </div>`;
        });
        html += `</div></div>`;

        // Skills for this modality (use first entry's skills, apply to all)
        const firstEntry = modEntries[0];
        html += `<div>
          <label style="display: block; margin-bottom: 0.25rem; font-size: 0.8rem; font-weight: 600; color: #555;">Skills: <span style="font-weight: normal; color: #888;">(w = weighted)</span></label>
          <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 0.3rem;">`;

        SKILLS.forEach(skill => {
          const val = firstEntry.skills[skill] || 0;
          html += `<div style="display: flex; align-items: center; gap: 0.2rem;">
            <select id="edit-${modKey}-skill-${skill}" style="padding: 0.2rem; font-size: 0.8rem; width: 45px;">
              <option value="-1" ${val === -1 ? 'selected' : ''}>-1</option>
              <option value="0" ${val === 0 ? 'selected' : ''}>0</option>
              <option value="1" ${val === 1 ? 'selected' : ''}>1</option>
              <option value="2" ${val === 2 ? 'selected' : ''}>w</option>
            </select>
            <span style="font-size: 0.75rem;">${escapeHtml(skill)}</span>
          </div>`;
        });
        html += `</div></div>`;

        html += `</div>`; // End modality section
      });

      // Add New Shift section
      html += `<div style="margin-bottom: 1rem; padding: 0.75rem; background: #d4edda; border: 2px solid #28a745; border-radius: 8px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
          <label style="font-weight: 600; color: #155724;">+ Add New Shift</label>
          <button class="btn btn-small btn-success" type="button" onclick="addShiftFromModal()">Add Shift</button>
        </div>
        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: flex-end;">
          <div style="display: flex; flex-direction: column;">
            <label style="font-size: 0.7rem; color: #666;">Task/Role</label>
            <select id="modal-add-task" onchange="onModalTaskChange()" style="padding: 0.3rem; font-size: 0.8rem; min-width: 150px;">
              <option value="">-- Select Task --</option>`;
      TASK_ROLES.forEach(task => {
        html += `<option value="${escapeHtml(task.name)}" data-modalities='${JSON.stringify(task.modalities || [])}' data-shift="${escapeHtml(task.shift || 'Fruehdienst')}" data-skills='${JSON.stringify(task.base_skills || {})}' data-modifier="${task.modifier || 1.0}">${escapeHtml(task.name)}</option>`;
      });
      html += `</select>
          </div>
          <div style="display: flex; flex-direction: column;">
            <label style="font-size: 0.7rem; color: #666;">Modality</label>
            <select id="modal-add-modality" style="padding: 0.3rem; font-size: 0.8rem;">`;
      MODALITIES.forEach(mod => {
        html += `<option value="${mod}">${mod.toUpperCase()}</option>`;
      });
      html += `</select>
          </div>
          <div style="display: flex; flex-direction: column;">
            <label style="font-size: 0.7rem; color: #666;">Start</label>
            <input type="time" id="modal-add-start" value="07:00" style="padding: 0.3rem; font-size: 0.8rem;">
          </div>
          <div style="display: flex; flex-direction: column;">
            <label style="font-size: 0.7rem; color: #666;">End</label>
            <input type="time" id="modal-add-end" value="15:00" style="padding: 0.3rem; font-size: 0.8rem;">
          </div>
          <div style="display: flex; flex-direction: column;">
            <label style="font-size: 0.7rem; color: #666;">Modifier</label>
            <select id="modal-add-modifier" style="padding: 0.3rem; font-size: 0.8rem;">
              <option value="0.5">0.5x</option>
              <option value="0.75">0.75x</option>
              <option value="1.0" selected>1.0x</option>
              <option value="1.25">1.25x</option>
              <option value="1.5">1.5x</option>
            </select>
          </div>
        </div>
        <div id="modal-add-skills" style="margin-top: 0.5rem; display: none;">
          <label style="font-size: 0.7rem; color: #666;">Skills:</label>
          <div style="display: flex; gap: 0.4rem; flex-wrap: wrap; margin-top: 0.2rem;">`;
      SKILLS.forEach(skill => {
        html += `<div style="display: flex; align-items: center; gap: 0.15rem;">
            <select id="modal-add-skill-${skill}" style="padding: 0.15rem; font-size: 0.75rem; width: 40px;">
              <option value="-1">-1</option>
              <option value="0" selected>0</option>
              <option value="1">1</option>
              <option value="2">w</option>
            </select>
            <span style="font-size: 0.7rem;">${escapeHtml(skill)}</span>
          </div>`;
      });
      html += `</div>
        </div>
      </div>`;

      // Gap section (simplified - applies to selected modality)
      if (workerModalities.length > 0) {
        html += `<div style="margin-bottom: 1rem; padding: 0.75rem; background: #fff3cd; border-radius: 4px;">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Add Gap (optional):</label>
          <p style="font-size: 0.75rem; color: #856404; margin: 0 0 0.5rem 0;">
            <strong>Note:</strong> Gaps modify shift times. Gap at start/end adjusts times. Gap in middle splits into two entries.
          </p>
          <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
            <select id="edit-gap-modality" style="padding: 0.4rem; font-size: 0.85rem;">
              ${workerModalities.map(mod => `<option value="${mod}">${mod.toUpperCase()}</option>`).join('')}
            </select>
            <select id="edit-gap-type" onchange="onEditGapTypeChange()" style="padding: 0.4rem; min-width: 120px;">
              <option value="">-- No Gap --</option>
              <option value="custom">Custom Time</option>`;
        EXCLUSION_RULES.forEach(rule => {
          html += `<option value="${rule.match}" data-schedule='${JSON.stringify(rule.schedule || {})}'>${rule.match}</option>`;
        });
        html += `</select>
            <input type="time" id="edit-gap-start" value="12:00" style="padding: 0.4rem;" disabled>
            <span>-</span>
            <input type="time" id="edit-gap-end" value="13:00" style="padding: 0.4rem;" disabled>
          </div>
        </div>`;
      }

      document.getElementById('modal-title').textContent = `Edit Worker - ${group.worker}`;
      document.getElementById('modal-content').innerHTML = html;
    }

    // Handle task change in modal add shift section
    function onModalTaskChange() {
      const taskSelect = document.getElementById('modal-add-task');
      const modalitySelect = document.getElementById('modal-add-modality');
      const skillsContainer = document.getElementById('modal-add-skills');

      const option = taskSelect.options[taskSelect.selectedIndex];
      if (!option || !option.value) {
        skillsContainer.style.display = 'none';
        return;
      }

      skillsContainer.style.display = 'block';

      // Set modality from task config
      const modalities = JSON.parse(option.dataset.modalities || '[]');
      if (modalities.length > 0) {
        modalitySelect.value = modalities[0];
      }

      // Set times from shift config
      const shiftName = option.dataset.shift || 'Fruehdienst';
      const shiftConfig = SHIFT_TIMES[shiftName] || {};
      const shiftDefault = shiftConfig.default || '07:00-15:00';
      const [startTime, endTime] = shiftDefault.split('-');
      document.getElementById('modal-add-start').value = startTime;
      document.getElementById('modal-add-end').value = endTime;

      // Set modifier from task config
      const modifier = option.dataset.modifier || '1.0';
      document.getElementById('modal-add-modifier').value = modifier;

      // Set skills from task config
      const taskSkills = JSON.parse(option.dataset.skills || '{}');
      SKILLS.forEach(skill => {
        const skillSelect = document.getElementById(`modal-add-skill-${skill}`);
        if (skillSelect) {
          const val = taskSkills[skill] !== undefined ? taskSkills[skill] : 0;
          skillSelect.value = val.toString();
        }
      });

      // Merge with worker roster skills (apply -1 exclusions)
      const { tab, groupIdx } = currentEditEntry || {};
      const group = entriesData[tab]?.[groupIdx];
      if (group) {
        const preset = WORKER_SKILLS[group.worker];
        if (preset) {
          const rosterSkills = preset.skills || preset;
          SKILLS.forEach(skill => {
            const taskVal = taskSkills[skill];
            if (taskVal === undefined || taskVal <= 0) {
              const skillSelect = document.getElementById(`modal-add-skill-${skill}`);
              if (skillSelect && rosterSkills && rosterSkills[skill] === -1) {
                skillSelect.value = '-1';
              }
            }
          });
        }
      }
    }

    // Add shift from modal
    async function addShiftFromModal() {
      const { tab, groupIdx } = currentEditEntry || {};
      const group = entriesData[tab]?.[groupIdx];
      if (!group) return;

      const taskSelect = document.getElementById('modal-add-task');
      const taskName = taskSelect.value;
      const modality = document.getElementById('modal-add-modality').value;
      const startTime = document.getElementById('modal-add-start').value;
      const endTime = document.getElementById('modal-add-end').value;
      const modifier = parseFloat(document.getElementById('modal-add-modifier').value) || 1.0;

      // Gather skills
      const skills = {};
      SKILLS.forEach(skill => {
        const el = document.getElementById(`modal-add-skill-${skill}`);
        skills[skill] = el ? parseInt(el.value) : 0;
      });

      const endpoint = tab === 'today' ? '/api/live-schedule/add-worker' : '/api/prep-next-day/add-worker';

      try {
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            modality,
            worker_data: {
              PPL: group.worker,
              start_time: startTime,
              end_time: endTime,
              Modifier: modifier,
              tasks: taskName,
              ...skills
            }
          })
        });

        if (response.ok) {
          showMessage('success', `Added new shift for ${group.worker}`);
          closeModal();
          await loadData();
        } else {
          const errData = await response.json().catch(() => ({}));
          showMessage('error', errData.error || 'Failed to add shift');
        }
      } catch (error) {
        showMessage('error', error.message);
      }
    }

    // Helper functions for modality colors (from config)
    function getModalityColor(modKey) {
      const settings = MODALITY_SETTINGS[modKey];
      return settings?.nav_color || '#6c757d';
    }

    function getModalityBgColor(modKey) {
      const settings = MODALITY_SETTINGS[modKey];
      return settings?.background_color || '#f8f9fa';
    }

    function onEditGapTypeChange() {
      const select = document.getElementById('edit-gap-type');
      const startInput = document.getElementById('edit-gap-start');
      const endInput = document.getElementById('edit-gap-end');

      if (!select.value) {
        startInput.disabled = true;
        endInput.disabled = true;
        return;
      }

      startInput.disabled = false;
      endInput.disabled = false;

      const option = select.options[select.selectedIndex];
      if (option.value !== 'custom' && option.dataset.schedule) {
        const schedule = JSON.parse(option.dataset.schedule);
        const days = ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
        const today = days[new Date().getDay()];
        if (schedule[today]) {
          const [start, end] = schedule[today].split('-');
          startInput.value = start;
          endInput.value = end;
        }
      }
    }

    function applySkillValues(skillMap = {}) {
      SKILLS.forEach(skill => {
        if (skillMap[skill] !== undefined) {
          const el = document.getElementById(`edit-skill-${skill}`);
          if (el) {
            el.value = skillMap[skill];
          }
        }
      });
    }

    function applyTaskSkillPreset() {
      const taskSelect = document.getElementById('edit-task');
      if (!taskSelect) return;
      const option = taskSelect.options[taskSelect.selectedIndex];
      if (!option || !option.dataset.skills) return;

      try {
        const skills = JSON.parse(option.dataset.skills) || {};
        applySkillValues(skills);

        // Also apply modifier from task config
        const taskName = option.value;
        const taskConfig = TASK_ROLES.find(t => t.name === taskName);
        if (taskConfig && taskConfig.modifier !== undefined) {
          const modifierSelect = document.getElementById('edit-modifier');
          if (modifierSelect) {
            modifierSelect.value = taskConfig.modifier.toString();
          }
        }
      } catch (err) {
        console.error('Failed to apply task skill preset', err);
      }
    }

    function applyWorkerSkillPreset(workerName) {
      // Legacy function - kept for compatibility
      const preset = WORKER_SKILLS[workerName];
      if (!preset) {
        showMessage('error', `No skill preset found for ${workerName}`);
        return;
      }

      const skills = preset.skills || preset;

      const sanitized = {};
      SKILLS.forEach(skill => {
        if (skills && skills[skill] !== undefined) {
          // Limit roster presets to 0/-1; positive values are reserved for manual/CSV edits
          const val = skills[skill];
          sanitized[skill] = val > 0 ? 0 : val;
        }
      });

      applySkillValues(sanitized);
    }

    // Apply worker skill preset for a specific modality
    function applyWorkerSkillPresetForModality(workerName, modKey) {
      const preset = WORKER_SKILLS[workerName];
      if (!preset) {
        showMessage('error', `No skill preset found for ${workerName}`);
        return;
      }

      // Check for modality-specific override first, then default
      const modalitySkills = preset[modKey] ? preset[modKey] : null;
      const skills = modalitySkills || preset.skills || preset;

      SKILLS.forEach(skill => {
        const el = document.getElementById(`edit-${modKey}-skill-${skill}`);
        if (el && skills && skills[skill] !== undefined) {
          // Limit roster presets to 0/-1; positive values are reserved for manual/CSV edits
          const val = skills[skill];
          el.value = (val > 0 ? 0 : val).toString();
        }
      });
    }

    async function saveModalChanges() {
      if (!currentEditEntry) return;

      const { tab, groupIdx } = currentEditEntry;
      const group = entriesData[tab][groupIdx];
      if (!group) return;

      const endpoint = tab === 'today' ? '/api/live-schedule/update-row' : '/api/prep-next-day/update-row';
      const modalityEntries = group.byModality || {};
      const workerModalities = Object.keys(modalityEntries);

      try {
        // Update all entries for all modalities
        for (const modKey of workerModalities) {
          const modEntries = modalityEntries[modKey] || [];

          // Get skills for this modality (same for all time slots)
          const skillUpdates = {};
          SKILLS.forEach(skill => {
            const el = document.getElementById(`edit-${modKey}-skill-${skill}`);
            if (el) {
              skillUpdates[skill] = parseInt(el.value);
            }
          });

          // Update each entry (time slot) in this modality
          for (let eIdx = 0; eIdx < modEntries.length; eIdx++) {
            const entry = modEntries[eIdx];

            // Get time/modifier for this specific time slot
            const startTimeEl = document.getElementById(`edit-${modKey}-${eIdx}-start`);
            const endTimeEl = document.getElementById(`edit-${modKey}-${eIdx}-end`);
            const modifierEl = document.getElementById(`edit-${modKey}-${eIdx}-modifier`);
            const rowIndexEl = document.getElementById(`edit-${modKey}-${eIdx}-rowindex`);

            if (!startTimeEl || !endTimeEl || !rowIndexEl) continue;

            const startTime = startTimeEl.value;
            const endTime = endTimeEl.value;
            const modifier = modifierEl ? parseFloat(modifierEl.value) || 1.0 : 1.0;
            const rowIndex = parseInt(rowIndexEl.value);

            const updates = {
              start_time: startTime,
              end_time: endTime,
              Modifier: modifier,
              ...skillUpdates
            };

            const response = await fetch(endpoint, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                modality: modKey,
                row_index: rowIndex,
                updates: updates
              })
            });

            if (!response.ok) {
              const result = await response.json();
              throw new Error(result.error || `Failed to update ${modKey.toUpperCase()} entry`);
            }
          }
        }

        // Check if gap needs to be added
        const gapTypeEl = document.getElementById('edit-gap-type');
        const gapModalityEl = document.getElementById('edit-gap-modality');

        if (gapTypeEl && gapTypeEl.value && gapModalityEl) {
          const gapType = gapTypeEl.value;
          const gapModality = gapModalityEl.value;
          const gapStart = document.getElementById('edit-gap-start').value;
          const gapEnd = document.getElementById('edit-gap-end').value;

          // Validate gap times
          if (gapStart >= gapEnd) {
            throw new Error('Gap start time must be before end time');
          }

          // Get the first entry for the selected modality
          const gapModEntries = modalityEntries[gapModality] || [];
          if (gapModEntries.length > 0) {
            const gapEndpoint = tab === 'today' ? '/api/live-schedule/add-gap' : '/api/prep-next-day/add-gap';

            const gapResponse = await fetch(gapEndpoint, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                modality: gapModality,
                row_index: gapModEntries[0].row_index,
                gap_type: gapType,
                gap_start: gapStart,
                gap_end: gapEnd
              })
            });

            if (!gapResponse.ok) {
              const gapResult = await gapResponse.json().catch(() => ({}));
              throw new Error(gapResult.error || 'Failed to add gap');
            }
          }
        }

        closeModal();
        showMessage('success', 'Worker entries updated');
        await loadData();
      } catch (error) {
        showMessage('error', error.message);
      }
    }

    function closeModal() {
      document.getElementById('edit-modal').classList.remove('show');
      currentEditEntry = null;
    }


    // Load from CSV
    async function loadFromCSV(mode) {
      const statusId = mode === 'today' ? 'load-status-today' : 'load-status-tomorrow';
      const loadStatus = document.getElementById(statusId);
      loadStatus.textContent = 'Loading...';

      const endpoint = mode === 'today' ? '/load-today-from-master' : '/preload-from-master';

      try {
        const response = await fetch(endpoint, { method: 'POST' });
        const result = await response.json();

        if (response.ok) {
          loadStatus.textContent = result.message || 'Loaded!';
          loadStatus.style.color = '#28a745';
          await loadData();
        } else {
          loadStatus.textContent = result.error || 'Error';
          loadStatus.style.color = '#dc3545';
        }
      } catch (error) {
        loadStatus.textContent = 'Error: ' + error.message;
        loadStatus.style.color = '#dc3545';
      }

      setTimeout(() => { loadStatus.textContent = ''; }, 5000);
    }

    // Show message (XSS-safe)
    function showMessage(type, message) {
      const container = document.getElementById('message-container');
      const div = document.createElement('div');
      div.className = `message ${type}`;
      div.textContent = message;  // textContent is XSS-safe
      container.innerHTML = '';
      container.appendChild(div);
      setTimeout(() => { container.innerHTML = ''; }, 5000);
    }

    // Initialize - only load current tab (lazy loading)
    loadTabData('today');
  </script>
</body>
</html>
