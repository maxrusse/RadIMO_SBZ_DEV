<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RadIMO Cortex | Timetable</title>
  <style>
    :root {
      --disabled-color:  #888;
      --primary-color:   #004892;
      --global-accent:   #004892;
      --body-bg:         #f0f0f0;
      --header-bg:       #fff;
      --tab-bg:          #fff;
      --tab-color:       #000;
      --card-bg:         #fff;
      --timeline-start:  6;  /* 6:00 */
      --timeline-end:    20; /* 20:00 */
      --timeline-hours:  14; /* 20 - 6 */
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      padding: 1rem;
      max-width: 1400px;
      margin: 0 auto;
    }

    body[data-modality] {
      background: var(--modality-bg, var(--body-bg));
    }

    {% for key, settings in modalities.items() %}
    body[data-modality="{{ key }}"] {
      --modality-bg: {{ settings.background_color }};
      --modality-nav: {{ settings.nav_color }};
      --modality-hover: {{ settings.hover_color }};
    }
    {% endfor %}

    .premium-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--header-bg);
      padding: 1rem 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 1rem;
    }
    .premium-header h1 {
      font-size: 1.75rem;
      margin: 0;
    }

    /* Filter bars */
    .skill-filter-bar {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
      padding: 0.75rem;
      background: white;
      border-radius: 8px;
      flex-wrap: wrap;
      align-items: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .skill-filter-bar label {
      font-weight: 600;
      color: #333;
      margin-right: 0.5rem;
    }
    .filter-btn {
      padding: 0.5rem 1rem;
      border: 2px solid #ddd;
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
      font-weight: 500;
      text-decoration: none;
      color: inherit;
    }
    .filter-btn:hover {
      border-color: #004892;
      background: #f0f0f0;
    }
    .filter-btn.active {
      background: #004892;
      color: white;
      border-color: #004892;
    }

    {% for skill in skill_definitions %}
    .filter-btn[data-skill="{{ skill.label }}"].active {
      background: {{ skill.button_color }};
      border-color: {{ skill.button_color }};
      color: white;
    }
    {% endfor %}

    /* Timeline container */
    .card {
      background: var(--card-bg);
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .timeline-wrapper {
      overflow-x: auto;
      overflow-y: auto;
      max-height: 65vh;
    }

    .timeline-grid {
      display: grid;
      grid-template-columns: 120px 1fr;
      min-width: 800px;
    }

    /* Time header */
    .time-header {
      grid-column: 2;
      display: flex;
      border-bottom: 2px solid #ddd;
      background: #f8f9fa;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .time-header-label {
      grid-column: 1;
      background: #f8f9fa;
      border-bottom: 2px solid #ddd;
      padding: 0.5rem;
      font-weight: 600;
      position: sticky;
      top: 0;
      left: 0;
      z-index: 11;
    }
    .time-slot {
      flex: 1;
      text-align: center;
      padding: 0.5rem 0;
      font-size: 0.75rem;
      color: #666;
      border-left: 1px solid #eee;
    }
    .time-slot:first-child { border-left: none; }

    /* Worker rows */
    .worker-row {
      display: contents;
    }
    .worker-name-cell {
      padding: 0.5rem;
      font-size: 0.85rem;
      font-weight: 500;
      background: #fff;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
      position: sticky;
      left: 0;
      z-index: 5;
      min-height: 36px;
    }
    .worker-timeline {
      position: relative;
      height: 36px;
      background: linear-gradient(90deg,
        transparent calc(100% / 14 * 0), #f0f0f0 calc(100% / 14 * 0), #f0f0f0 calc(100% / 14 * 0 + 1px),
        transparent calc(100% / 14 * 1), #f0f0f0 calc(100% / 14 * 1), #f0f0f0 calc(100% / 14 * 1 + 1px),
        transparent calc(100% / 14 * 2), #f0f0f0 calc(100% / 14 * 2), #f0f0f0 calc(100% / 14 * 2 + 1px),
        transparent calc(100% / 14 * 3), #f0f0f0 calc(100% / 14 * 3), #f0f0f0 calc(100% / 14 * 3 + 1px),
        transparent calc(100% / 14 * 4), #f0f0f0 calc(100% / 14 * 4), #f0f0f0 calc(100% / 14 * 4 + 1px),
        transparent calc(100% / 14 * 5), #f0f0f0 calc(100% / 14 * 5), #f0f0f0 calc(100% / 14 * 5 + 1px),
        transparent calc(100% / 14 * 6), #f0f0f0 calc(100% / 14 * 6), #f0f0f0 calc(100% / 14 * 6 + 1px),
        transparent calc(100% / 14 * 7), #f0f0f0 calc(100% / 14 * 7), #f0f0f0 calc(100% / 14 * 7 + 1px),
        transparent calc(100% / 14 * 8), #f0f0f0 calc(100% / 14 * 8), #f0f0f0 calc(100% / 14 * 8 + 1px),
        transparent calc(100% / 14 * 9), #f0f0f0 calc(100% / 14 * 9), #f0f0f0 calc(100% / 14 * 9 + 1px),
        transparent calc(100% / 14 * 10), #f0f0f0 calc(100% / 14 * 10), #f0f0f0 calc(100% / 14 * 10 + 1px),
        transparent calc(100% / 14 * 11), #f0f0f0 calc(100% / 14 * 11), #f0f0f0 calc(100% / 14 * 11 + 1px),
        transparent calc(100% / 14 * 12), #f0f0f0 calc(100% / 14 * 12), #f0f0f0 calc(100% / 14 * 12 + 1px),
        transparent calc(100% / 14 * 13), #f0f0f0 calc(100% / 14 * 13), #f0f0f0 calc(100% / 14 * 13 + 1px),
        transparent 100%
      );
      border-bottom: 1px solid #eee;
    }

    /* Shift bars */
    .shift-bar {
      position: absolute;
      top: 4px;
      height: 28px;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.15);
      cursor: default;
      overflow: hidden;
      transition: opacity 0.15s;
    }
    .shift-bar:hover {
      z-index: 2;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    /* Tooltip */
    .shift-bar[title] {
      position: relative;
    }

    /* Current time indicator - contained within timeline grid */
    .timeline-grid {
      position: relative;
    }
    .current-time-line {
      position: absolute;
      top: 32px; /* Below header */
      bottom: 0;
      width: 2px;
      background: #dc3545;
      z-index: 8;
      pointer-events: none;
    }
    .current-time-line::before {
      content: '';
      position: absolute;
      top: 0;
      left: -4px;
      width: 10px;
      height: 10px;
      background: #dc3545;
      border-radius: 50%;
    }


    /* Legend */
    .legend {
      display: flex;
      gap: 1rem;
      margin-top: 0.5rem;
      flex-wrap: wrap;
    }
    .legend-item {
      display: flex;
      align-items: center;
      font-size: 0.85rem;
    }
    .legend-box {
      width: 15px;
      height: 15px;
      margin-right: 0.5rem;
      border: 1px solid #ddd;
      border-radius: 3px;
    }

    /* Back button */
    .back-button {
      display: inline-block;
      padding: 0.75rem 1.5rem;
      color: #fff;
      text-decoration: none;
      border-radius: 4px;
      font-size: 1rem;
      margin-top: 1rem;
      background: var(--modality-nav, var(--primary-color));
      transition: background 0.3s;
    }
    .back-button:hover {
      background: var(--modality-hover, #003f73);
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 3rem;
      color: #666;
    }

    /* Skill colors for stripes */
    {% for skill in skill_definitions %}
    .skill-stripe-{{ skill.slug }} { background-color: {{ skill.button_color }}; }
    {% endfor %}
  </style>
</head>
<body data-modality="{{ modality }}">
  <header class="premium-header">
    <div>
      <h1>RadIMO Cortex</h1>
      <p style="margin: 0; opacity: 0.8; font-size: 0.9rem;">Intelligent Radiology Orchestration</p>
    </div>
    <nav style="display: flex; gap: 1rem; align-items: center;">
      <a href="{{ url_for('index', modality=modality) }}" style="color: #333; text-decoration: none;">Dashboard</a>
      <a href="{{ url_for('timetable', modality=modality) }}" style="font-weight: bold; color: #004892; text-decoration: none; border-bottom: 2px solid #004892;">Timetable</a>
      <a href="{{ url_for('upload_file', modality=modality) }}" style="color: #333; text-decoration: none; padding: 0.4rem 0.8rem; background: #004892; color: white; border-radius: 4px;">Admin</a>
    </nav>
  </header>

  <!-- Modality Filter Bar -->
  <div class="skill-filter-bar">
    <label>Modality:</label>
    <a href="{{ url_for('timetable', modality='all') }}" class="filter-btn {% if modality == 'all' %}active{% endif %}">ALL</a>
    {% for mod in modality_order %}
    <a href="{{ url_for('timetable', modality=mod) }}" class="filter-btn {% if modality == mod %}active{% endif %}" style="{% if modality == mod %}background: {{ modalities[mod].nav_color }}; border-color: {{ modalities[mod].nav_color }}; color: white;{% endif %}">{{ modality_labels[mod] }}</a>
    {% endfor %}
  </div>

  <!-- Skill Filter Bar -->
  <div class="skill-filter-bar">
    <label>Filter by Skill:</label>
    <button class="filter-btn active" data-skill="all" onclick="filterBySkill('all')">All</button>
    {% for skill in skill_definitions %}
    <button class="filter-btn" data-skill="{{ skill.slug }}" onclick="filterBySkill('{{ skill.slug }}')" style="border-left: 4px solid {{ skill.button_color }};">{{ skill.label }}</button>
    {% endfor %}
  </div>

  <div class="card">
    <div class="timeline-wrapper">
      <div id="timeline-grid" class="timeline-grid" data-filter="all">
        <!-- Time header label -->
        <div class="time-header-label">Worker</div>
        <!-- Time header row -->
        <div class="time-header" id="time-header"></div>
        <!-- Worker rows inserted here by JS -->
      </div>
    </div>
    <div class="legend">
      {% for skill in skill_definitions %}
        <div class="legend-item">
          <div class="legend-box" style="background: {{ skill.button_color }};"></div> {{ skill.label }}
        </div>
      {% endfor %}
    </div>
  </div>

  <a href="{{ url_for('index', modality=modality) }}" class="back-button">Zur√ºck zur Hauptseite</a>

  <script>
    // Configuration from server
    const skillColumns = {{ skill_columns|tojson }};
    const skillSlugMap = {{ skill_slug_map|tojson }};
    const skillColorMap = {{ skill_color_map|tojson }};
    const modColorMap = {{ modality_color_map|tojson }};
    const currentModality = '{{ modality }}';
    const isAllView = currentModality === 'all';

    // Timeline config
    const TIMELINE_START = 6;  // 6:00
    const TIMELINE_END = 20;   // 20:00
    const TIMELINE_HOURS = TIMELINE_END - TIMELINE_START;

    // Check if skill is active (matches edit day logic)
    function isSkillActive(val) {
      if (val === 'w' || val === 'W') return true;
      const n = Number(val);
      return !isNaN(n) && n >= 1;
    }

    // Check if any skill is active (for ALL filter - includes excluded -1)
    function hasAnyActiveSkill(entry) {
      return skillColumns.some(s => {
        const val = entry[s];
        if (val === 'w' || val === 'W') return true;
        const n = Number(val);
        return !isNaN(n) && (n >= 1 || n === -1);
      });
    }

    // Convert time string to minutes for comparison (with null check)
    function timeToMinutes(timeStr) {
      if (!timeStr || typeof timeStr !== 'string') return 0;
      const parts = timeStr.split(':');
      if (parts.length < 2) return 0;
      const [h, m] = parts.map(Number);
      return (h || 0) * 60 + (m || 0);
    }

    // Convert time string to percentage position (with null check)
    function timeToPercent(timeStr) {
      if (!timeStr || typeof timeStr !== 'string') return 0;
      const parts = timeStr.split(':');
      if (parts.length < 2) return 0;
      const [h, m] = parts.map(Number);
      const hours = (h || 0) + (m || 0) / 60;
      const clamped = Math.max(TIMELINE_START, Math.min(TIMELINE_END, hours));
      return ((clamped - TIMELINE_START) / TIMELINE_HOURS) * 100;
    }

    // Build gradient for skill stripes
    function buildSkillGradient(skills) {
      if (!skills || skills.length === 0) return '#ddd';
      if (skills.length === 1) {
        const color = skillColorMap[skills[0]] || '#ccc';
        return `repeating-linear-gradient(90deg, ${color} 0, ${color} 10px, #fff 10px, #fff 25px)`;
      }
      const sw = 10, gw = 15;
      const colors = skills.map(s => skillColorMap[s] || '#ccc');
      const stops = colors.map((c, i) => `${c} ${i * sw}px, ${c} ${(i + 1) * sw}px`);
      const bw = colors.length * sw;
      stops.push(`#fff ${bw}px, #fff ${bw + gw}px`);
      return `repeating-linear-gradient(90deg, ${stops.join(', ')})`;
    }

    // Escape HTML
    function escapeHtml(text) {
      if (text == null) return '';
      const div = document.createElement('div');
      div.textContent = String(text);
      return div.innerHTML;
    }

    // Merge entries with same time range, combining skills across modalities
    function mergeEntriesByTime(entries) {
      const timeMap = new Map();

      entries.forEach(entry => {
        const timeKey = `${entry.start_time}-${entry.end_time}`;
        if (!timeMap.has(timeKey)) {
          timeMap.set(timeKey, {
            start_time: entry.start_time,
            end_time: entry.end_time,
            TIME: entry.TIME,
            modalities: new Set(),
            skillValues: {} // skill -> max value across modalities
          });
        }
        const merged = timeMap.get(timeKey);
        if (entry._modality) merged.modalities.add(entry._modality.toUpperCase());

        // Merge skills - take highest active value for each skill
        skillColumns.forEach(s => {
          const val = entry[s];
          const isActive = isSkillActive(val);
          if (isActive) {
            // Store the skill as active if any modality has it active
            merged.skillValues[s] = 1;
          }
        });
      });

      return Array.from(timeMap.values());
    }

    // Build the timeline
    function buildTimeline() {
      const grid = document.getElementById('timeline-grid');
      const header = document.getElementById('time-header');

      // Parse data
      let data;
      try {
        data = JSON.parse('{{ debug_data|safe }}');
      } catch (e) {
        grid.innerHTML = '<div class="empty-state">Error loading timeline data</div>';
        return;
      }

      // Filter out empty entries and entries without active skills
      data = data.filter(e => e.TIME !== '00:00-00:00' && hasAnyActiveSkill(e));

      if (!data.length) {
        grid.innerHTML = '<div class="empty-state">No active schedule entries found</div>';
        return;
      }

      // Build time header
      header.innerHTML = '';
      for (let h = TIMELINE_START; h < TIMELINE_END; h++) {
        const slot = document.createElement('div');
        slot.className = 'time-slot';
        slot.textContent = `${h}:00`;
        header.appendChild(slot);
      }

      // Group entries by worker name (merge across modalities in ALL view)
      const workerMap = new Map();
      data.forEach(entry => {
        const worker = entry.PPL;
        if (!workerMap.has(worker)) {
          workerMap.set(worker, []);
        }
        workerMap.get(worker).push(entry);
      });

      // Sort workers by earliest start time
      const sortedWorkers = Array.from(workerMap.entries()).sort((a, b) => {
        const aStart = Math.min(...a[1].map(e => timeToMinutes(e.start_time)));
        const bStart = Math.min(...b[1].map(e => timeToMinutes(e.start_time)));
        return aStart - bStart;
      });

      // Create worker rows
      sortedWorkers.forEach(([worker, entries]) => {
        // In ALL view, merge entries by time slot
        const processedEntries = isAllView ? mergeEntriesByTime(entries) : entries;

        // Collect all skills this worker has (across all entries)
        const workerSkills = new Set();
        processedEntries.forEach(entry => {
          if (isAllView) {
            // For merged entries, check skillValues
            Object.keys(entry.skillValues || {}).forEach(s => {
              workerSkills.add(skillSlugMap[s] || s.toLowerCase());
            });
          } else {
            skillColumns.forEach(s => {
              if (isSkillActive(entry[s])) {
                workerSkills.add(skillSlugMap[s] || s.toLowerCase());
              }
            });
          }
        });

        const row = document.createElement('div');
        row.className = 'worker-row';
        row.dataset.worker = worker;
        row.dataset.skills = Array.from(workerSkills).join(',');

        // Worker name cell
        const nameCell = document.createElement('div');
        nameCell.className = 'worker-name-cell';
        nameCell.textContent = worker;

        // Timeline cell
        const timelineCell = document.createElement('div');
        timelineCell.className = 'worker-timeline';

        // Create shift bars
        processedEntries.forEach(entry => {
          const left = timeToPercent(entry.start_time);
          const right = timeToPercent(entry.end_time);
          const width = right - left;

          if (width <= 0) return;

          let activeSkills;
          let tooltipMods = '';

          if (isAllView && entry.skillValues) {
            // Merged entry - get skills from skillValues
            activeSkills = Object.keys(entry.skillValues)
              .map(s => skillSlugMap[s] || s.toLowerCase());
            if (entry.modalities && entry.modalities.size > 0) {
              tooltipMods = `Modalities: ${Array.from(entry.modalities).join(', ')}\n`;
            }
          } else {
            // Single modality entry
            activeSkills = skillColumns
              .filter(s => isSkillActive(entry[s]))
              .map(s => skillSlugMap[s] || s.toLowerCase());
            if (entry._modality) {
              tooltipMods = `Modality: ${entry._modality.toUpperCase()}\n`;
            }
          }

          const bar = document.createElement('div');
          bar.className = 'shift-bar';
          bar.style.left = `${left}%`;
          bar.style.width = `${width}%`;
          bar.style.background = buildSkillGradient(activeSkills);
          bar.dataset.skills = activeSkills.join(',');

          // Tooltip
          bar.title = `${worker}\n${tooltipMods}Zeit: ${entry.TIME}\nSkills: ${activeSkills.join(', ')}`;

          timelineCell.appendChild(bar);
        });

        row.appendChild(nameCell);
        row.appendChild(timelineCell);
        grid.appendChild(row);
      });

      // Add current time indicator
      updateCurrentTimeLine();
      setInterval(updateCurrentTimeLine, 60000); // Update every minute
    }

    // Update current time line - positioned within timeline grid
    function updateCurrentTimeLine() {
      const existing = document.getElementById('current-time-line');
      if (existing) existing.remove();

      const now = new Date();
      const currentHour = now.getHours() + now.getMinutes() / 60;

      // Only show if within timeline bounds
      if (currentHour < TIMELINE_START || currentHour > TIMELINE_END) return;

      const percent = ((currentHour - TIMELINE_START) / TIMELINE_HOURS) * 100;

      const grid = document.getElementById('timeline-grid');
      const line = document.createElement('div');
      line.id = 'current-time-line';
      line.className = 'current-time-line';
      // Position: 120px for worker column + percentage of remaining width
      line.style.left = `calc(120px + (100% - 120px) * ${percent / 100})`;

      grid.appendChild(line);
    }

    // Filter by skill - simple show/hide based on skill presence
    function filterBySkill(skillSlug) {
      const grid = document.getElementById('timeline-grid');
      const buttons = document.querySelectorAll('.skill-filter-bar .filter-btn[data-skill]');

      // Update button states
      buttons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.skill === skillSlug);
      });

      // Update filter state
      grid.dataset.filter = skillSlug;

      // Filter rows - simply show/hide based on skill (no opacity changes)
      const rows = grid.querySelectorAll('.worker-row');
      rows.forEach(row => {
        if (skillSlug === 'all') {
          row.style.display = '';
        } else {
          const workerSkills = (row.dataset.skills || '').split(',').filter(s => s);
          const hasSkill = workerSkills.some(ws => ws === skillSlug);
          row.style.display = hasSkill ? '' : 'none';
        }
      });
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', buildTimeline);
  </script>
</body>
</html>
