<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RadIMO Cortex | Timetable</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='vis.min.css') }}">
  <style>
    :root {
      --disabled-color:  #888;

      /* Global & Other Colors */
      --primary-color:   #004892;
      --global-accent:   #004892;
      --body-bg:         #f0f0f0;
      --header-bg:       #fff;
      --tab-bg:          #fff;
      --tab-color:       #000;
      --card-bg:         #fff;
      --info-box-border: #dc3545;
      --info-item-bg:    #fff;
      --info-item-shadow: rgba(0, 0, 0, 0.05);
      --card-header-bg:  #f8f9fa;
      --stats-header-bg: #f8f9fa;
      --table-header-bg: #f8f9fa;
      --highlight-bg:    rgba(0, 0, 0, 0.05);
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      padding: 1rem;
      max-width: 1400px;
      margin: 0 auto;
    }

    /* Background based on modality */
    body[data-modality] {
      background: var(--modality-bg, var(--body-bg));
    }

    {% for key, settings in modalities.items() %}
    body[data-modality="{{ key }}"] {
      --modality-bg: {{ settings.background_color }};
      --modality-nav: {{ settings.nav_color }};
      --modality-hover: {{ settings.hover_color }};
    }
    {% endfor %}
    /* Premium header mimicking the admin page */
    .premium-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--header-bg);
      padding: 1rem 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 1rem;
    }
    .premium-header h1 {
      font-size: 1.75rem;
      margin: 0;
    }
    .modality-selector {
      display: flex;
      gap: 1rem;
    }
    .modality-selector a {
      text-decoration: none;
      font-weight: bold;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      background: var(--tab-bg);
      color: var(--tab-color);
      border: 2px solid;
      transition: border-width 0.2s;
    }
    {% for key, settings in modalities.items() %}
    .modality-selector a[data-modality="{{ key }}"] {
      border-color: {{ settings.nav_color }};
    }
    {% endfor %}
    .modality-selector a.active {
      border-width: 4px;
    }
    .card {
      background: var(--card-bg);
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      padding: 1rem;
      margin-bottom: 1rem;
    }
    .timeline-card {
      margin-bottom: 1rem;
    }
    #timeline-container {
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 1rem;
      background: #fff;
      min-height: 150px;
    }
    .legend {
      display: flex;
      gap: 1rem;
      margin-top: 0.5rem;
    }
    .legend-item {
      display: flex;
      align-items: center;
      font-size: 0.9rem;
    }
    .legend-box {
      width: 15px;
      height: 15px;
      margin-right: 0.5rem;
      border: 1px solid #ddd;
      border-radius: 3px;
    }
    /* Back button similar to admin page style */
    .back-button {
      display: inline-block;
      padding: 0.75rem 1.5rem;
      color: #fff;
      text-decoration: none;
      border-radius: 4px;
      font-size: 1rem;
      margin-top: 1rem;
      background: var(--modality-nav, var(--primary-color));
      transition: background 0.3s;
    }
    .back-button:hover {
      background: var(--modality-hover, #003f73);
    }

    /* Skill Filter Bar */
    .skill-filter-bar {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
      padding: 0.75rem;
      background: white;
      border-radius: 8px;
      flex-wrap: wrap;
      align-items: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .skill-filter-bar label {
      font-weight: 600;
      color: #333;
      margin-right: 0.5rem;
    }

    .filter-btn {
      padding: 0.5rem 1rem;
      border: 2px solid #ddd;
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
      font-weight: 500;
    }

    .filter-btn:hover {
      border-color: #004892;
      background: #f0f0f0;
    }

    .filter-btn.active {
      background: #004892;
      color: white;
      border-color: #004892;
    }

    /* Skill-specific colors when active */
    {% for skill in skill_definitions %}
    .filter-btn[data-skill="{{ skill.label }}"].active {
      background: {{ skill.button_color }};
      border-color: {{ skill.button_color }};
      color: white;
    }
    {% endfor %}
  </style>
</head>
<body data-modality="{{ modality }}">
  <header class="premium-header">
    <div>
      <h1>RadIMO Cortex</h1>
      <p style="margin: 0; opacity: 0.8; font-size: 0.9rem;">Intelligent Radiology Orchestration</p>
    </div>
    <nav style="display: flex; gap: 1rem; align-items: center;">
      <a href="{{ url_for('index', modality=modality) }}" style="color: #333; text-decoration: none;">Dashboard</a>
      <a href="{{ url_for('timetable', modality=modality) }}" style="font-weight: bold; color: #004892; text-decoration: none; border-bottom: 2px solid #004892;">Timetable</a>
      <a href="{{ url_for('upload_file', modality=modality) }}" style="color: #333; text-decoration: none; padding: 0.4rem 0.8rem; background: #004892; color: white; border-radius: 4px;">Admin</a>
    </nav>
  </header>

  <!-- Modality Filter Bar -->
  <div class="skill-filter-bar">
    <label>Modality:</label>
    <a href="{{ url_for('timetable', modality='all') }}" class="filter-btn {% if modality == 'all' %}active{% endif %}">ALL</a>
    {% for mod in modality_order %}
    <a href="{{ url_for('timetable', modality=mod) }}" class="filter-btn {% if modality == mod %}active{% endif %}" style="{% if modality == mod %}background: {{ modalities[mod].nav_color }}; border-color: {{ modalities[mod].nav_color }}; color: white;{% endif %}">{{ modality_labels[mod] }}</a>
    {% endfor %}
  </div>

  <!-- Skill Filter Bar -->
  <div class="skill-filter-bar">
    <label>Filter by Skill:</label>
    <button class="filter-btn active" data-skill="all" onclick="filterTimeline('all')">All</button>
    {% for skill in skill_definitions %}
    <button class="filter-btn" data-skill="{{ skill.label }}" onclick="filterTimeline('{{ skill.label }}')" style="border-left: 4px solid {{ skill.button_color }};">{{ skill.label }}</button>
    {% endfor %}
  </div>

  <div class="card timeline-card">
    <div id="timeline-container"></div>
    <div class="legend">
      {% for skill in skill_definitions %}
        <div class="legend-item">
          <div class="legend-box" style="background: {{ skill.button_color }};"></div> {{ skill.label }}
        </div>
      {% endfor %}
    </div>
  </div>
  
  <a href="{{ url_for('index', modality=modality) }}" class="back-button">Zur√ºck zur Hauptseite</a>
  
  <script src="{{ url_for('static', filename='vis.min.js') }}"></script>
  <script>
    const skillColumns = {{ skill_columns|tojson }};
    const skillSlugMap = {{ skill_slug_map|tojson }};
    const skillColorMap = {{ skill_color_map|tojson }};

    // Global variables for filtering
    let originalData = null;
    let timelineInstance = null;
    let currentFilter = 'all';

    function buildGradient(skills) {
      const stripeWidth = 10;
      const gapWidth = 15;
      if (!skills || skills.length === 0) {
        return "background: #ffffff;";
      }
      const colors = skills.map(slug => skillColorMap[slug] || '#cccccc');
      if (colors.length === 1) {
        const color = colors[0];
        return `background: repeating-linear-gradient(
          90deg,
          ${color} 0px,
          ${color} ${stripeWidth}px,
          #ffffff ${stripeWidth}px,
          #ffffff ${stripeWidth + gapWidth}px
        );`;
      }
      const stops = colors.map((color, idx) => {
        const start = idx * stripeWidth;
        const end = start + stripeWidth;
        return `${color} ${start}px, ${color} ${end}px`;
      });
      const blockWidth = colors.length * stripeWidth;
      stops.push(`#ffffff ${blockWidth}px, #ffffff ${blockWidth + gapWidth}px`);
      const period = blockWidth + gapWidth;
      return `background: repeating-linear-gradient(90deg, ${stops.join(', ')}, #ffffff ${period}px);`;
    }
    
    function buildTimeline() {
      const timelineContainer = document.getElementById('timeline-container');
      let dfData;
      try {
        dfData = JSON.parse('{{ debug_data|safe }}');
      } catch (e) {
        console.error("Failed to parse timeline data:", e);
        timelineContainer.innerHTML = "<p>Error loading timeline data</p>";
        return;
      }
      // Filter out placeholder entries
      dfData = dfData.filter(entry => entry.TIME !== '00:00-00:00');
      if (dfData.length === 0) {
        timelineContainer.innerHTML = "<p>No active schedule entries found</p>";
        return;
      }

      // Store original data globally for filtering
      originalData = dfData;

      // Build initial timeline with all data
      renderTimeline(originalData);
    }

    function renderTimeline(dfData) {
      const timelineContainer = document.getElementById('timeline-container');

      if (!dfData || dfData.length === 0) {
        timelineContainer.innerHTML = "<p>No workers match the selected filter</p>";
        return;
      }
      const items = [];
      const groups = [];
      const groupMap = {};
      dfData.forEach((entry) => {
        const groupId = entry.PPL;
        const startTimeParts = entry.start_time.split(':');
        const startDateTime = new Date();
        startDateTime.setHours(parseInt(startTimeParts[0], 10), parseInt(startTimeParts[1], 10), 0);
        if (!groupMap[groupId]) {
          groupMap[groupId] = { id: groupId, order: startDateTime };
          groups.push(groupMap[groupId]);
        } else {
          if (startDateTime < groupMap[groupId].order) {
            groupMap[groupId].order = startDateTime;
          }
        }
      });
      groups.sort((a, b) => a.order - b.order);
      const finalGroups = groups.map(group => ({ id: group.id, content: group.id }));
      dfData.forEach((entry, index) => {
        const startTimeParts = entry.start_time.split(':');
        const endTimeParts = entry.end_time.split(':');
        const startDateTime = new Date();
        startDateTime.setHours(parseInt(startTimeParts[0], 10), parseInt(startTimeParts[1], 10), 0);
        const endDateTime = new Date();
        endDateTime.setHours(parseInt(endTimeParts[0], 10), parseInt(endTimeParts[1], 10), 0);
        const activeSkills = [];
        skillColumns.forEach(skillName => {
          if (entry[skillName] > 0) {
            const slug = skillSlugMap[skillName] || skillName.toLowerCase();
            activeSkills.push(slug);
          }
        });
        const customClass = `timeline-item-${index}`;
        const customStyle = document.createElement('style');
        customStyle.textContent = `.${customClass} { ${buildGradient(activeSkills)} }`;
        document.head.appendChild(customStyle);
        // Build tooltip with modality info if available
        const modalityInfo = entry._modality ? `<br>Modality: ${entry._modality.toUpperCase()}` : '';
        items.push({
          id: index,
          group: entry.PPL,
          start: startDateTime,
          end: endDateTime,
          content: '',
          title: `${entry.PPL}${modalityInfo}<br>Zeit: ${entry.TIME}<br>Skills: ${activeSkills.join(', ')}`,
          className: customClass
        });
      });
      // Create date objects for timeline bounds (don't mutate same object)
      const now = new Date();
      const minTime = new Date();
      minTime.setHours(6, 0, 0, 0);
      const maxTime = new Date();
      maxTime.setHours(20, 0, 0, 0);

      const options = {
        zoomable: true,
        moveable: true,
        stack: false,
        min: minTime,
        max: maxTime,
        showCurrentTime: true,
        format: {
          minorLabels: {
            hour: 'HH:mm',
            minute: 'HH:mm'
          }
        },
        orientation: {
          axis: 'top',
          item: 'top'
        },
        margin: { item: { vertical: 10 } },
        verticalScroll: true,
      };
      // Destroy existing timeline if it exists
      if (timelineInstance) {
        timelineInstance.destroy();
      }

      const timeline = new vis.Timeline(timelineContainer, items, finalGroups, options);
      timelineInstance = timeline;

      setInterval(() => {
        if (timelineInstance) {
          timelineInstance.setCurrentTime(new Date());
        }
      }, 60000);

      // Set initial window around current time
      const windowStart = new Date();
      windowStart.setHours(Math.max(6, now.getHours() - 1), 0, 0, 0);
      const windowEnd = new Date();
      windowEnd.setHours(Math.min(20, now.getHours() + 3), 0, 0, 0);
      timeline.setWindow(windowStart, windowEnd);
    }

    /**
     * Filter timeline by skill
     * @param {string} skill - The skill to filter by ('all' or skill name)
     */
    function filterTimeline(skill) {
      // Update button states - only for skill filter bar (second one)
      const skillFilterBars = document.querySelectorAll('.skill-filter-bar');
      if (skillFilterBars.length > 1) {
        const buttons = skillFilterBars[1].querySelectorAll('.filter-btn');
        buttons.forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');
      }

      currentFilter = skill;

      if (skill === 'all') {
        // Show all workers
        renderTimeline(originalData);
      } else {
        // Filter data to show only workers with this skill active (value = 1)
        const filteredData = originalData.filter(entry => {
          // Check if this entry has the skill active
          const skillValue = entry[skill];
          return skillValue && skillValue === 1;
        });

        renderTimeline(filteredData);
      }
    }
    
    document.addEventListener('DOMContentLoaded', function() {
      buildTimeline();
    });
  </script>
</body>
</html>
